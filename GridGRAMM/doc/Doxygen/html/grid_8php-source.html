<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>GridGRAMM: grid.php Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>grid.php</h1><a href="grid_8php.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 &lt;?
00002 
00003 require_once(<span class="stringliteral">"./config.php"</span>);
00004 require_once(<span class="stringliteral">"./util.php"</span>);
00005 <span class="comment"></span>
00006 <span class="comment">/**</span>
00007 <span class="comment"> *  Grid access class</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *  CAUTION: THIS CLASS IS UNDERGOING A GENERAL OVERHAUL. DO NOT USE</span>
00010 <span class="comment"> *  NOW.</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  This class allows you to connect to a remote Grid UI server and</span>
00013 <span class="comment"> *  launch and monitor jobs on it.</span>
00014 <span class="comment"> *</span>
00015 <span class="comment"> *  The reason for this class is mostly one of resilience: if you </span>
00016 <span class="comment"> *  put all your services directly on a GrUI host, then whenever </span>
00017 <span class="comment"> *  that host if offline, your services will be as well.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> *  An alternative is to replicate the services on various GrUI nodes.</span>
00020 <span class="comment"> *</span>
00021 <span class="comment"> *  Or better yet: use this class and set up your services wherever</span>
00022 <span class="comment"> *  you want. You may put them on an HA system and ensure this way </span>
00023 <span class="comment"> *  their continuous availability. Your service will be always up</span>
00024 <span class="comment"> *  and running, ready to accept jobs.</span>
00025 <span class="comment"> *</span>
00026 <span class="comment"> *  Your next problem is dealing with the Grid UI. You still need</span>
00027 <span class="comment"> *  to log-in on a Grid access point to submit your jobs. But once</span>
00028 <span class="comment"> *  you have detached from a specific GrUI node, you are free to</span>
00029 <span class="comment"> *  attempt a connection to a given remote access point, and if it</span>
00030 <span class="comment"> *  is available (and while it is) submit jobs as needed. If at any</span>
00031 <span class="comment"> *  time it is not available, nothing is lost: just look for another</span>
00032 <span class="comment"> *  one and use this to continue working. You may thus enter the</span>
00033 <span class="comment"> *  grid through any door.</span>
00034 <span class="comment"> *</span>
00035 <span class="comment"> *  There is a side advantage too: with your services on a GrUI node</span>
00036 <span class="comment"> *  you can only launch jobs from it. With your services detached from</span>
00037 <span class="comment"> *  any given Grid door, you may use _any_ AND _as many_ as you want:</span>
00038 <span class="comment"> *  this means you may launch jobs using various GrUI nodes simultaneously</span>
00039 <span class="comment"> *  if you so wish. And even split the jobs througho various, separate </span>
00040 <span class="comment"> *  Grids if you feel like it, hence potentially increasing your </span>
00041 <span class="comment"> *  throughput and computing power, harnessing even more resources.</span>
00042 <span class="comment"> *</span>
00043 <span class="comment"> *  Detaching your jobs from the GrUI has one serious drawback though:</span>
00044 <span class="comment"> *  all your job information must travel from your service user interface</span>
00045 <span class="comment"> *  to the grid user interface through the Internet, which may be</span>
00046 <span class="comment"> *  potentially dangerous. We deal with this security issue using SSH</span>
00047 <span class="comment"> *  to handle all communications and provide encryption. As long as </span>
00048 <span class="comment"> *  you use strong passwords you may feel secure. Actually, it is as</span>
00049 <span class="comment"> *  weak (or strong) as working directly on the GrUI node: access to</span>
00050 <span class="comment"> *  it is still managed by standard password mechanisms and subject to</span>
00051 <span class="comment"> *  the same types of attacks. However, remember you now have an extra</span>
00052 <span class="comment"> *  system (the front-end) to maintain and secure. Please, be always</span>
00053 <span class="comment"> *  cautious with any server you use.</span>
00054 <span class="comment"> *</span>
00055 <span class="comment"> *  Sounds convincing? Then read ahead to learn how to use this class.</span>
00056 <span class="comment"> *</span>
00057 <span class="comment"> *  Using this class you may access the Grid in two different ways:</span>
00058 <span class="comment"> *  connected or disconnected mode (or if you prefer, using persistent</span>
00059 <span class="comment"> *  connections or disconnected mode).</span>
00060 <span class="comment"> *</span>
00061 <span class="comment"> *  It is important to understand the differences among them:</span>
00062 <span class="comment"> *</span>
00063 <span class="comment"> *  PERSISTENT CONNECTIONS</span>
00064 <span class="comment"> *</span>
00065 <span class="comment"> *  When working with persistent connections, you first issue a</span>
00066 <span class="comment"> *  Grid::connect() call to stablish a connection to the GrUI. This will</span>
00067 <span class="comment"> *  be kept open during all the time until you call Grid::disconnect().</span>
00068 <span class="comment"> *  All commands issued will travel over the same wire, and hence </span>
00069 <span class="comment"> *  communications will be more efficient.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> *  Output of all your commands is collected on a single I/O channel</span>
00072 <span class="comment"> *  that persists during the whole session.</span>
00073 <span class="comment"> *</span>
00074 <span class="comment"> *  On the minus side, persistent connections drive all communications</span>
00075 <span class="comment"> *  between your front-end and the grid access point through pipes, and</span>
00076 <span class="comment"> *  are subject to serious deadlock problems. You must make sure you</span>
00077 <span class="comment"> *  avoid them by clearing periodically the communication buffers. In</span>
00078 <span class="comment"> *  addition, error checking is relayed to YOU: all information will </span>
00079 <span class="comment"> *  travel through the persistent I/O channels, and it will be YOUR</span>
00080 <span class="comment"> *  responsability to detect errors and act accordingly. Debugging is</span>
00081 <span class="comment"> *  thus more difficult.</span>
00082 <span class="comment"> *</span>
00083 <span class="comment"> *  DISCONNECTED MODE</span>
00084 <span class="comment"> *</span>
00085 <span class="comment"> *  When working in disconnected mode, the connections are open and</span>
00086 <span class="comment"> *  closed for each command you issue. This imposes a heavier tax</span>
00087 <span class="comment"> *  on your communications, which may become serious for submitting</span>
00088 <span class="comment"> *  huge numbers of jobs.</span>
00089 <span class="comment"> *</span>
00090 <span class="comment"> *  Each command will return its output separately since it uses a</span>
00091 <span class="comment"> *  new I/O channel every time.</span>
00092 <span class="comment"> *</span>
00093 <span class="comment"> *  On the plus side, you will retrieve job completion status inmediately</span>
00094 <span class="comment"> *  and won't risk deadlocks while running remote jobs. Development and</span>
00095 <span class="comment"> *  debugging will be a lot easier.</span>
00096 <span class="comment"> *</span>
00097 <span class="comment"> *  JOB MANAGEMENT</span>
00098 <span class="comment"> *</span>
00099 <span class="comment"> *  In order to submit your jobs to the grid you need to understand how</span>
00100 <span class="comment"> *  job management has been defined for this class. On the command line</span>
00101 <span class="comment"> *  you would have a lot more versatility, but to make this class more</span>
00102 <span class="comment"> *  useful some compromises had to be reached. We have defined a strict</span>
00103 <span class="comment"> *  protocol to generate/prepare your jobs before submitting them to</span>
00104 <span class="comment"> *  the grid, and you must stick to it if you want to avoid problems.</span>
00105 <span class="comment"> *</span>
00106 <span class="comment"> *  To understand why this has been designed the way it is, you should</span>
00107 <span class="comment"> *  keep in mind that you will be preparing your jobs on one (or many)</span>
00108 <span class="comment"> *  front-end and submitting them from it to one (or many) GrUI nodes.</span>
00109 <span class="comment"> *  Further to it, this has been designhed to make it easy to deploy</span>
00110 <span class="comment"> *  web-based services for users. Therefore many similar jobs might</span>
00111 <span class="comment"> *  be launched simultaneously and we need some way to avoid collusion</span>
00112 <span class="comment"> *  among them. To avoid one job stepping over other we must isolate</span>
00113 <span class="comment"> *  every one from each other. This means providing an isolated environment</span>
00114 <span class="comment"> *  for every job.</span>
00115 <span class="comment"> *</span>
00116 <span class="comment"> *  The easiest way to achieve our goal is to have every job submitted</span>
00117 <span class="comment"> *  placed on an independent directory (which we pair to the job name). </span>
00118 <span class="comment"> *  For single jobs, this means that you should make sure that no two </span>
00119 <span class="comment"> *  potentially simultaneous/overlapping jobs have the same name (i.e. </span>
00120 <span class="comment"> *  are stored in the same directory so there is no risk one overwrites</span>
00121 <span class="comment"> *  files of the other).</span>
00122 <span class="comment"> *</span>
00123 <span class="comment"> *  Sometimes this may result inconvenient to you. E.g. if your whole job</span>
00124 <span class="comment"> *  is submitted split into many separate sub-jobs (which each is a separate</span>
00125 <span class="comment"> *  job from the point of view of the grid) you may want to follow some</span>
00126 <span class="comment"> *  naming convention for your sub-jobs that makes it easier to identify</span>
00127 <span class="comment"> *  and keep track of them. In this case, if you had two simultaneous</span>
00128 <span class="comment"> *  runs, then the names would collide.</span>
00129 <span class="comment"> *</span>
00130 <span class="comment"> *  For example, let's say you are rendering frames of a movie and want</span>
00131 <span class="comment"> *  to identify each job by frame number: 0000, 0001, 0002, 0003... If</span>
00132 <span class="comment"> *  you now try to generate a second movie while the first is being</span>
00133 <span class="comment"> *  processed, then the frames of the second movie (named as well 0000,</span>
00134 <span class="comment"> *  0001, etc...) would overwrite the frames of the first one.</span>
00135 <span class="comment"> *  Generating random names for each frame would be an option, but too</span>
00136 <span class="comment"> *  cumbersome and expensive as you would need to keep track of the</span>
00137 <span class="comment"> *  association of the random names with the actual frames.</span>
00138 <span class="comment"> *</span>
00139 <span class="comment"> *  To deal with this scenario we define 'sessions'. A session is identified</span>
00140 <span class="comment"> *  by a unique identifier, and guarantees that all jobs belonging to this</span>
00141 <span class="comment"> *  session are kept separate from similarly named jobs from other sessions.</span>
00142 <span class="comment"> *</span>
00143 <span class="comment"> *  Actually when you create a session, what we actually do is create</span>
00144 <span class="comment"> *  a subdirectory in the GrUI and direct all further jobs to this </span>
00145 <span class="comment"> *  subdirectory. This way, jobs of two sessions may have the same name</span>
00146 <span class="comment"> *  and not step into each other.</span>
00147 <span class="comment"> *</span>
00148 <span class="comment"> *  PREPARING JOBS FOR THE GRID</span>
00149 <span class="comment"> *</span>
00150 <span class="comment"> *  To prepare a job for the grid you must assign it a name. The same</span>
00151 <span class="comment"> *  preacutions that apply to any local job hold for your grid work too:</span>
00152 <span class="comment"> *  if various simultaneous jobs of the same kind may be run, then each</span>
00153 <span class="comment"> *  must be kept separate from the others by using a different name.</span>
00154 <span class="comment"> *</span>
00155 <span class="comment"> *  Once you have decided the name, you must create a directory locally</span>
00156 <span class="comment"> *  with the same name as your job. In this directory you must install</span>
00157 <span class="comment"> *  everything needed to run your job: executables, libraries, input</span>
00158 <span class="comment"> *  data and a JDL file.</span>
00159 <span class="comment"> *</span>
00160 <span class="comment"> *  The JDL file defines the work that we will ask the grid to carry</span>
00161 <span class="comment"> *  out. Since each single job gets its own directory, you will only</span>
00162 <span class="comment"> *  submit one JDL file for each, and to make processing easier, we</span>
00163 <span class="comment"> *  request that this JDL file have a fixed name: "job.jdl".</span>
00164 <span class="comment"> *</span>
00165 <span class="comment"> *  The grid processing will generate various auxiliary files, for internal</span>
00166 <span class="comment"> *  housekeeping. Again, for simplicity, we have chosen to call each of</span>
00167 <span class="comment"> *  them 'job.*', i.e. 'job.' something. This means that other than 'job.jdl'</span>
00168 <span class="comment"> *  you should NOT create any file named job.anything on your job directory</span>
00169 <span class="comment"> *  to avoid collusion with possible temporary files.</span>
00170 <span class="comment"> *</span>
00171 <span class="comment"> *  In brief, to prepare a job:</span>
00172 <span class="comment"> *  - select a name</span>
00173 <span class="comment"> *  - create a directory named after the job</span>
00174 <span class="comment"> *  - populate this directory with all files needed to run your job</span>
00175 <span class="comment"> *  - generate the file 'job.jdl' with the description of the work to</span>
00176 <span class="comment"> *    be carried out by the grid</span>
00177 <span class="comment"> *  - avoid having files named 'job.*' (starting with 'job.')</span>
00178 <span class="comment"> *</span>
00179 <span class="comment"> *  SUBMITTING JOBS TO THE GRID</span>
00180 <span class="comment"> *</span>
00181 <span class="comment"> *  First consider whether you will be using unique job names or if</span>
00182 <span class="comment"> *  you will follow a convenient naming convention that may cause name</span>
00183 <span class="comment"> *  collisions with other jobs.</span>
00184 <span class="comment"> *</span>
00185 <span class="comment"> *  If you feel pretty safe that the job name is unique (e.g. has been</span>
00186 <span class="comment"> *  generated using one or more random strings), then simply call the</span>
00187 <span class="comment"> *  appropriate *job_submit() function.</span>
00188 <span class="comment"> *</span>
00189 <span class="comment"> *  If you are using names that have low entropy or reusing names for</span>
00190 <span class="comment"> *  similar jobs then it is advisable that you first call one of the</span>
00191 <span class="comment"> *  *new_session() routines to ensure all your jobs will be kept isolated</span>
00192 <span class="comment"> *  from other similarly named jobs, and then use the *job_submit()</span>
00193 <span class="comment"> *  routines to send your jobs.</span>
00194 <span class="comment"> *</span>
00195 <span class="comment"> *  For the curious: when you submit your job, the directory and all</span>
00196 <span class="comment"> *  of its contents will be sent to the remote Grid UI selected and</span>
00197 <span class="comment"> *  then the 'job.jdl' will be submitted to the grid. In the process,</span>
00198 <span class="comment"> *  several files will be generated holding information about your</span>
00199 <span class="comment"> *  job identity in the grid context that will be kept for housekeeping</span>
00200 <span class="comment"> *  and future reference.</span>
00201 <span class="comment"> *</span>
00202 <span class="comment"> *  The above is to be kept in mind when submitting light or numerous</span>
00203 <span class="comment"> *  jobs: the transfer time may become sensibly relevant. Please do </span>
00204 <span class="comment"> *  take it into consideration in your equations when designing jobs</span>
00205 <span class="comment"> *  for the grid using this class. You may find it interesting to first</span>
00206 <span class="comment"> *  store all or some of your job data/execs on the grid and keep them</span>
00207 <span class="comment"> *  already there instead of having to copy them.</span>
00208 <span class="comment"> *</span>
00209 <span class="comment"> *  Grid file management routines are not included yet, but are intended</span>
00210 <span class="comment"> *  for a future release of this class.</span>
00211 <span class="comment"> *</span>
00212 <span class="comment"> */</span>
<a name="l00213"></a><a class="code" href="classGrid.html">00213</a> <span class="keyword">class </span><a class="code" href="classGrid.html">Grid</a> {
00214 
<a name="l00215"></a><a class="code" href="classGrid.html#o0">00215</a>     var <a class="code" href="classGrid.html#o0">$entry_point</a>;   <span class="comment">/**&lt; the grid entry point, should not be needed */</span>
<a name="l00216"></a><a class="code" href="classGrid.html#o1">00216</a>     var <a class="code" href="classGrid.html#o1">$username</a>;      <span class="comment">/**&lt; user name to use to connect to the grid */</span>
<a name="l00217"></a><a class="code" href="classGrid.html#o2">00217</a>     var <a class="code" href="classGrid.html#o2">$hostname</a>;      <span class="comment">/**&lt; name of host that provides access to the grid */</span>
<a name="l00218"></a><a class="code" href="classGrid.html#o3">00218</a>     var <a class="code" href="classGrid.html#o3">$password</a>;      <span class="comment">/**&lt; password to login on the UI node */</span>
<a name="l00219"></a><a class="code" href="classGrid.html#o4">00219</a>     var <a class="code" href="classGrid.html#o4">$passphrase</a>;    <span class="comment">/**&lt; key to unlock the grid access certificate */</span>
<a name="l00220"></a><a class="code" href="classGrid.html#o5">00220</a>     var <a class="code" href="classGrid.html#o5">$work_dir</a>;      <span class="comment">/**&lt; a GrUI directory where we can work */</span>
<a name="l00221"></a><a class="code" href="classGrid.html#o6">00221</a>     var <a class="code" href="classGrid.html#o6">$error_log</a>;     <span class="comment">/**&lt; a local file to store the error log */</span>
00222     
<a name="l00223"></a><a class="code" href="classGrid.html#o7">00223</a>     var <a class="code" href="classGrid.html#o7">$std_in</a>;        <span class="comment">/**&lt; Internal. Standard input of the grid entry */</span>
<a name="l00224"></a><a class="code" href="classGrid.html#o8">00224</a>     var <a class="code" href="classGrid.html#o8">$std_out</a>;       <span class="comment">/**&lt; Internal. Standard output of the grid entry */</span>
<a name="l00225"></a><a class="code" href="classGrid.html#o9">00225</a>     var <a class="code" href="classGrid.html#o9">$std_err</a>;       <span class="comment">/**&lt; Internal. Standard error of the grid entry */</span>
00226                         <span class="comment">// !!! IMPORTANT !!! either:</span>
00227                         <span class="comment">//      a. set files to not hang on wait or</span>
00228                         <span class="comment">//      b. remember to set them to no-hang when needed</span>
00229 
<a name="l00230"></a><a class="code" href="classGrid.html#o10">00230</a>     var <a class="code" href="classGrid.html#o10">$connected</a>;     <span class="comment">/**&lt; Internal: Have we already connected? */</span>
<a name="l00231"></a><a class="code" href="classGrid.html#o11">00231</a>     var <a class="code" href="classGrid.html#o11">$initialized</a>;   <span class="comment">/**&lt; Internal: Have we already identified ourselves? */</span>
00232     <span class="comment"></span>
00233 <span class="comment">    /**</span>
00234 <span class="comment">     * Constructor for the class</span>
00235 <span class="comment">     *</span>
00236 <span class="comment">     * Set the values for the class variables using defaults provided in</span>
00237 <span class="comment">     * 'config.php'</span>
00238 <span class="comment">     *</span>
00239 <span class="comment">     * These defaults can be overridden using the functions provided below.</span>
00240 <span class="comment">     */</span>
<a name="l00241"></a><a class="code" href="classGrid.html#a0">00241</a>     function <a class="code" href="classGrid.html#a0">Grid</a>() {
00242         $this-&gt;entry_point = $GLOBALS['grid_server'];
00243         $this-&gt;username    = $GLOBALS['grid_user'];
00244         $this-&gt;hostname    = $GLOBALS['grid_host'];
00245         $this-&gt;password    = $GLOBALS['grid_password'];
00246         $this-&gt;passphrase  = $GLOBALS['grid_passphrase'];
00247         $this-&gt;work_dir    = $GLOBALS['grid_wd_path'];
00248         $this-&gt;error_log   = $GLOBALS['grid_error_log'];
00249         $this-&gt;connected   = FALSE;
00250     }
00251     
00252     <span class="comment">// A C C E S S    V A R I A B L E    V A L U E S</span>
00253     <span class="comment">// Note: do we also need "get_XX" routines?</span>
00254 <span class="comment"></span>
00255 <span class="comment">    /**</span>
00256 <span class="comment">     * set the Grid user name</span>
00257 <span class="comment">     *</span>
00258 <span class="comment">     * @param user identity to use in the Grid UI host</span>
00259 <span class="comment">     */</span>
<a name="l00260"></a><a class="code" href="classGrid.html#a1">00260</a>     function <a class="code" href="classGrid.html#a1">set_user</a>($user)
00261     {
00262         $this-&gt;username = $user;
00263         $this-&gt;entry_point=$user.<span class="stringliteral">"</span><span class="stringliteral">@".$this-&gt;hostname;
    }
    </span><span class="comment"></span>
00264 <span class="comment">    /**</span>
00265 <span class="comment">     * set the name of the Grid access host</span>
00266 <span class="comment">     *</span>
00267 <span class="comment">     * @param host name of the remote UI host</span>
00268 <span class="comment">     */</span>
    function set_host($host)
    {
        $this-&gt;hostname = $host;
        $this-&gt;entry_point = $this-&gt;username."<span class="stringliteral">@".$host;
    }
    </span><span class="comment"></span>
00269 <span class="comment">    /**</span>
00270 <span class="comment">     * set the password for the remote grid user/server</span>
<a name="l00271"></a><a class="code" href="classGrid.html#a2">00271</a> <span class="comment">     *</span>
00272 <span class="comment">     *  This is specific to the remote UI server selected.</span>
00273 <span class="comment">     *</span>
00274 <span class="comment">     * @param pass password needed to login on to the grid UI server</span>
00275 <span class="comment">     */</span>
    function set_password($pass)
    {
        $this-&gt;password = $pass;
    }
<span class="comment"></span>
00276 <span class="comment">    /**</span>
00277 <span class="comment">     * set the passphrase for the remote grid user</span>
00278 <span class="comment">     *</span>
00279 <span class="comment">     *  This is grid-wise and independent of the UI-node used.</span>
00280 <span class="comment">     *</span>
00281 <span class="comment">     * @param pass passphrase needed to unlock the grid certificate</span>
00282 <span class="comment">     */</span>
    function set_passphrase($pass)
    {
        $this-&gt;passphrase = $pass;
    }
    <span class="comment"></span>
00283 <span class="comment">    /**</span>
<a name="l00284"></a><a class="code" href="classGrid.html#a3">00284</a> <span class="comment">     * set working directory on the Grid server</span>
00285 <span class="comment">     *</span>
00286 <span class="comment">     * @param work_dir the remote path of the working directory</span>
00287 <span class="comment">     */</span>
    function set_work_dir($wd)
    {
        $this-&gt;work_dir=$wd;
    }
    <span class="comment"></span>
00288 <span class="comment">    /**</span>
00289 <span class="comment">     * set error log</span>
00290 <span class="comment">     *</span>
00291 <span class="comment">     * @param errlog path to a local file where we will store the error log</span>
00292 <span class="comment">     *               (i.e. stderr of the grid connection)</span>
00293 <span class="comment">     */</span>
    function set_error_log($errlog)
    {
        $this-&gt;error_log = $errlog;
    }
    
    function get_connection_status()
    {
        return $this-&gt;connected;
    }

    function get_init_status()
    {
        return $this-&gt;initialized;
    }

//------ P E R S I S T E N T   G R I D   A C C E S S   F U N C T I O N S ------

    //
    // C O N N E C T    T O    T H E    U S E R    I N T E R F A C E   H O S T
    //
    <span class="comment"></span>
00294 <span class="comment">    /**</span>
00295 <span class="comment">     * open a persistent connection to the Grid UI server</span>
<a name="l00296"></a><a class="code" href="classGrid.html#a4">00296</a> <span class="comment">     * </span>
00297 <span class="comment">     *  The Grid User Interface Server is the entry point to the Grid</span>
00298 <span class="comment">     *  for users and user applications. This is where jobs are launched from.</span>
00299 <span class="comment">     * </span>
00300 <span class="comment">     *  This package has been designed to be able to be installed in any</span>
00301 <span class="comment">     *  host, independent of whether it is an UI or not. Thus, to be able to</span>
00302 <span class="comment">     *  submit jobs to the Grid, the server hosting the Web UI must connect to</span>
00303 <span class="comment">     *  a Grid UI host to do the work.</span>
00304 <span class="comment">     * </span>
00305 <span class="comment">     *  This routine opens a connection to a Grid UI host using an specified</span>
<a name="l00306"></a><a class="code" href="classGrid.html#a5">00306</a> <span class="comment">     *  username (i.e. all jobs will be run under said username). To allow the</span>
00307 <span class="comment">     *  caller to communicate with the remote end, it creates two pipes/pty, one for</span>
00308 <span class="comment">     *  input and one for output, and redirects error messages to a file.</span>
00309 <span class="comment">     *</span>
00310 <span class="comment">     *  We need to redirect stderr to a file. This is so to avoid blocking on</span>
00311 <span class="comment">     *  reading to check for errors and to avoid (if we use PTYs) interleave</span>
00312 <span class="comment">     *  of error messages and normal I/O.</span>
00313 <span class="comment">     * </span>
00314 <span class="comment">     *  These pipes lead to a child process that actually manages the </span>
00315 <span class="comment">     *  communication. Using a child process has several advantages: it simplifies</span>
00316 <span class="comment">     *  the communication process by offloading the comm. logic to a separate,</span>
<a name="l00317"></a><a class="code" href="classGrid.html#a6">00317</a> <span class="comment">     *  convenience tool, and by being able to use SSH as the child, we can increase</span>
00318 <span class="comment">     *  security taking advantage of its encryption capabilities.</span>
00319 <span class="comment">     * </span>
00320 <span class="comment">     *  The panorama therefore will look like this:</span>
00321 <span class="comment">     * </span>
<a name="l00322"></a><a class="code" href="classGrid.html#a7">00322</a> <span class="comment">     *  HTML front-end --&gt; processor.php &lt;--&gt; SSH &lt;--&gt; remote host &lt;--&gt; Grid</span>
00323 <span class="comment">     *</span>
00324 <span class="comment">     *  This allows for better resilience: should a GridUI host be </span>
00325 <span class="comment">     * unavailable, we can detect the error condition and try another </span>
00326 <span class="comment">     * one. If the GridUI runs the front-end, then we have a single</span>
<a name="l00327"></a><a class="code" href="classGrid.html#a8">00327</a> <span class="comment">     * point of failure, which is a no-no.</span>
00328 <span class="comment">     *</span>
00329 <span class="comment">     *  @note   Use of persistent connections is greatly DISCOURAGED:</span>
00330 <span class="comment">     * all I/O will go through pipes, and any end of the line may hang</span>
00331 <span class="comment">     * waiting on read (if there is nothing to be read at the other end)</span>
00332 <span class="comment">     * or write (if there is noone to retrieve the data at the other</span>
00333 <span class="comment">     * end).</span>
00334 <span class="comment">     *</span>
00335 <span class="comment">     *  Just picture this: you open a connection to a GridUI and the</span>
00336 <span class="comment">     * remote host issues an unusually large 'motd' that fills the</span>
00337 <span class="comment">     * pipe. The remote shell will hang waiting for someone to read and</span>
00338 <span class="comment">     * empty the pipe before continuing. Now, on the local side we do</span>
00339 <span class="comment">     * issue a remote command (without checking the output): we hang </span>
00340 <span class="comment">     * waiting for the other end to read it, but the other end is hung.</span>
00341 <span class="comment">     * Sadly a 'motd' may contain anything, and we can't predict what</span>
00342 <span class="comment">     * the remote prompt will look like...</span>
00343 <span class="comment">     *</span>
00344 <span class="comment">     *  Be careful. Be _very_ careful.</span>
00345 <span class="comment">     *</span>
00346 <span class="comment">     *  AND always consider setting the pipe ends to non-blocking status.</span>
00347 <span class="comment">     * This is actually the default, but has its tricks too. Be careful.</span>
00348 <span class="comment">     * Be _very_ careful.</span>
00349 <span class="comment">     *</span>
00350 <span class="comment">     *  @note   There is no easy way to know the exit status of a remote</span>
00351 <span class="comment">     * command while using persisten connections. Your only chance is to</span>
00352 <span class="comment">     * review the output log and check it yourself for error messages.</span>
00353 <span class="comment">     *</span>
00354 <span class="comment">     *  We could be doing better here, but for now we will leave this for</span>
00355 <span class="comment">     * later. After all, the point here is to give the user maximum</span>
00356 <span class="comment">     * efficiency.</span>
00357 <span class="comment">     *</span>
00358 <span class="comment">     *  @return TRUE on success, FALSE otherwise.</span>
00359 <span class="comment">     */</span>

    function pconnect()
    {   
        global $php_version;
        global $debug;
        
        // Open a child process with the 'proc_open' function. 
        //
        // Some tricks: we must open the connection using '-x' to disable
        // X11 forwarding, and use '-t -t' to avoid SSH generating an error
        // because we are not connected to any terminal.
        // NOTE:
        //   We require users to have an account and password on
        //   the UI and provide their user/password through the web or
        //   otherwise (e.g. using myproxy)
        //
        // NOTE: if the web server is trusted remotely (i.e. it's SSH public 
        // key is accepted in ~user@host:.ssh/authorized_keys) then any 
        // password will do.
        if ($php_version &lt; 5) {
            $descriptorspec = array(
                0 =&gt; array("pipe", <span class="stringliteral">"r"</span>),  <span class="comment">// connect child's stdin to the read end of a pipe</span>
00360                 1 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"w"</span>),  <span class="comment">// connect child's stdout to the write end of a pipe</span>
00361                 2 =&gt; array(<span class="stringliteral">"file"</span>, $this-&gt;error_log, <span class="stringliteral">"a"</span>) <span class="comment">// stderr is a file to write to</span>
00362             );
00363             $this-&gt;process = proc_open(<span class="stringliteral">"SSH/SSH.sh $this-&gt;entry_point"</span>, 
00364                              $descriptorspec,
00365                              $pipes);
00366             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"SSH/SSH.sh $this-&gt;entry_point&lt;br /&gt;\n"</span>;
00367             <span class="comment">// check status</span>
00368             <span class="keywordflow">if</span> (!is_resource($this-&gt;process)) 
00369             {
00370                 letal(<span class="stringliteral">"Grid::connect"</span>, <span class="stringliteral">"cannot connect to the Grid"</span>);
00371                 <span class="keywordflow">return</span> $this-&gt;connected = FALSE;
00372             }
00373             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"proc_open&lt;br /&gt;\n"</span>;
00374             <span class="comment">// give SSH it's due password</span>
00375             <span class="comment">// XXX - this might be better..</span>
00376             fwrite($pipes[0], <span class="stringliteral">"$this-&gt;password\n"</span>);
00377             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"$this-&gt;password&lt;br /&gt;\n"</span>;
00378             fflush($pipes[0]);
00379          
00380         }
00381         <span class="keywordflow">else</span> {  <span class="comment">/* php5 -- we can use PTYs */</span>
00382                 <span class="comment">/* XXX -- untested -- probably unneeded */</span>
00383             $descriptorspec = array(
00384                 0 =&gt; array(<span class="stringliteral">"pty"</span>),
00385                 1 =&gt; array(<span class="stringliteral">"pty"</span>),
00386                 2 =&gt; array(<span class="stringliteral">"file"</span>, $this-&gt;error_log, <span class="stringliteral">"a"</span>)
00387             );
00388             $this-&gt;process = proc_open(<span class="stringliteral">"ssh -x -t -t $this-&gt;entry_point"</span>, 
00389                              $descriptorspec,
00390                              $pipes);
00391                 
00392             <span class="comment">// check status</span>
00393             <span class="keywordflow">if</span> (!is_resource($this-&gt;process)) 
00394             {
00395                 letal(<span class="stringliteral">"Grid::connect"</span>, <span class="stringliteral">"cannot connect to the Grid"</span>);
00396                 <span class="keywordflow">return</span> $this-&gt;connected = FALSE;
00397             }
00398 
00399             <a class="code" href="results_8php.html#a2">$status</a> = proc_get_status($this-&gt;process);
00400             <span class="keywordflow">if</span> (<a class="code" href="results_8php.html#a2">$status</a>-&gt;running == FALSE) {
00401                 fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]);
00402                 proc_close($this-&gt;process);
00403                 letal(<span class="stringliteral">"Grid::connect"</span>, <span class="stringliteral">"connection exited "</span>.$status-&gt;exitcode);
00404                 <span class="keywordflow">return</span> $this-&gt;connected = FALSE;
<a name="l00405"></a><a class="code" href="classGrid.html#a9">00405</a>             }
00406             <span class="keywordflow">if</span> (<a class="code" href="results_8php.html#a2">$status</a>-&gt;signaled) {
00407                 fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]);
00408                 proc_close($this-&gt;process);
00409                 letal(<span class="stringliteral">"Grid::connect"</span>, <span class="stringliteral">"connection terminated by "</span>.$status-&gt;termsig);
00410                 <span class="keywordflow">return</span> $this-&gt;connected = FALSE;
00411             }
00412             <span class="keywordflow">if</span> (<a class="code" href="results_8php.html#a2">$status</a>-&gt;stopped) {
00413                 <span class="comment">// Tell the user and hope for the best</span>
00414                 warning(<span class="stringliteral">"Grid::connect stopped by "</span>.$status-&gt;stopsig.
00415                 <span class="stringliteral">" it may still have a chance though"</span>);
00416             }
00417 
00418             <span class="comment">// Give ssh it's due password</span>
00419             $dummy = fgets($pipes[1],1024);     <span class="comment">/* wait for prompt */</span>
00420             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a0">$debug</a>) echo $dummy.<span class="stringliteral">"&lt;br /&gt;\n"</span>;
00421             fwrite($pipes[0], <span class="stringliteral">"$this-&gt;password\n"</span>);
00422             fflush($pipes[0]);
00423 
00424         }
00425         
00426         <span class="comment">// $pipes now looks like this:</span>
00427         <span class="comment">//   0 =&gt; writeable handle connected to child stdin</span>
00428         <span class="comment">//   1 =&gt; readable handle connected to child stdout</span>
00429         <span class="comment">// Any error output will be appended to $wd_path/error-output.txt</span>
00430         $this-&gt;std_in = $pipes[0];
00431         $this-&gt;std_out = $pipes[1];
00432         $this-&gt;std_err = fopen($this-&gt;error_log, <span class="stringliteral">"r"</span>);
00433 
00434         <span class="comment">// We now have a connection to the remote Grid User Interface</span>
00435         <span class="comment">// Server which we may use to send commands/receive output</span>
00436         <span class="keywordflow">return</span> $this-&gt;connected = TRUE;
00437     }
00438 <span class="comment"></span>
00439 <span class="comment">    /**</span>
00440 <span class="comment">     * Close the connection with the remote Grid access point (UI node)</span>
00441 <span class="comment">     *</span>
00442 <span class="comment">     *  What we are going to do is close the communication pipes</span>
00443 <span class="comment">     *  and kill the child process that actually handles communication</span>
00444 <span class="comment">     *  with the remote Grid UI host (ssh).</span>
00445 <span class="comment">     *  This function returns the exit status of the connection (i.e. of</span>
00446 <span class="comment">     *  the intermediate program that handles the connection --in this</span>
00447 <span class="comment">     *  case SSH).</span>
00448 <span class="comment">     *</span>
00449 <span class="comment">     *  @return integer exit status of the connection (or the handling program)</span>
00450 <span class="comment">     */</span>
00451     function pdisconnect()
00452     {
00453         global <a class="code" href="grid__test_8php.html#a0">$debug</a>;
00454         <span class="keywordflow">if</span> ($this-&gt;connected == FALSE)
00455                 <span class="keywordflow">return</span> $ret = 0;
00456 
00457         <span class="comment">// We need to close the 'child' process, otherwise the call to</span>
00458         <span class="comment">// the 'proc_close()' function hangs!!!</span>
00459         fwrite($this-&gt;std_in, <span class="stringliteral">"logout\n"</span>);
00460         fflush($this-&gt;std_in);
00461 
00462         fclose($this-&gt;std_in);
00463 
00464         <span class="comment">// The output from the commands</span>
00465         <span class="comment">//  Note that this may</span>
00466         <span class="comment">//      a) disrupt normal output</span>
00467         <span class="comment">//      b) get into an infinite loop if the child is in one</span>
00468         <span class="comment">//  But it is useful for debugging, hence here.</span>
00469         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a0">$debug</a> == TRUE)
00470             <span class="keywordflow">do</span> {
00471             
00472                 $line = fgets($this-&gt;std_out, 1024);
00473                 echo $line.<span class="stringliteral">"&lt;br /&gt;\n"</span>;
00474             } <span class="keywordflow">while</span> (!feof($this-&gt;std_out) &amp;&amp; (strlen($line) != 0));
00475 
00476         fclose($this-&gt;std_out);
00477 
00478         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a0">$debug</a> == TRUE)
00479             <span class="keywordflow">do</span> {
00480             
00481                 $line = fgets($this-&gt;std_err, 1024);
00482                 echo $line.<span class="stringliteral">"&lt;br /&gt;\n"</span>;
00483             } <span class="keywordflow">while</span> (!feof($this-&gt;std_err) &amp;&amp; (strlen($line) != 0));
00484 
00485         fclose($this-&gt;std_err);
00486 
00487         <span class="comment">// It's important that we close any open files before calling</span>
00488         <span class="comment">// proc_close in order to avoid a deadlock</span>
00489 
00490         $return_value = proc_close($this-&gt;process);
00491         
00492         $this-&gt;connected = FALSE;
00493 
00494         <span class="keywordflow">return</span> $return_value;   
00495     }
00496     
00497     <span class="comment">// I D E N T I F Y    T O    T H E    G R I D</span>
00498     <span class="comment"></span>
00499 <span class="comment">    /**</span>
00500 <span class="comment">     * Start the Grid services</span>
00501 <span class="comment">     *</span>
00502 <span class="comment">     *  This function starts the grid services on the remote UI server host.</span>
00503 <span class="comment">     *  This is done by unlocking the certificate that we are going to use </span>
00504 <span class="comment">     *  to run our jobs on the grid using the passphrase provided.</span>
00505 <span class="comment">     *</span>
00506 <span class="comment">     *  We need to have a connection open with the remote grid server as the </span>
00507 <span class="comment">     *  user with whose identity we want to run the jobs. This connection is</span>
00508 <span class="comment">     *  created by Grid::pconnect().</span>
00509 <span class="comment">     *</span>
00510 <span class="comment">     *  To ease things up, we check if we are already connected, and if we</span>
00511 <span class="comment">     *  aren't, we try to connect ourselves. That is, there is no need to</span>
00512 <span class="comment">     *  call Grid::Connect() first unless you want to do something else</span>
00513 <span class="comment">     *  on the Grid-UI before initializing the Grid.</span>
00514 <span class="comment">     *</span>
00515 <span class="comment">     *  Grid services have a lifetime of their own. By default they are</span>
00516 <span class="comment">     *  available for 12:00 hours (that's the default value of</span>
<a name="l00517"></a><a class="code" href="classGrid.html#a10">00517</a> <span class="comment">     *  grid-proxy-init itself), but their duration may be fine tuned</span>
00518 <span class="comment">     *  if we have some knowledge about the time required to run our</span>
00519 <span class="comment">     *  job.</span>
00520 <span class="comment">     *</span>
00521 <span class="comment">     *  Session duration is specified in hours+minutes. If the number of</span>
00522 <span class="comment">     *  minutes is negative, the specified minutes are substracted from</span>
00523 <span class="comment">     *  the specified hours (e.g: 1, -15 is fifteen minutes to one hour,</span>
00524 <span class="comment">     *  i.e. 45 minutes). If the total time specified is negative then</span>
00525 <span class="comment">     *  the default of 12:00 is used.</span>
00526 <span class="comment">     *</span>
00527 <span class="comment">     *  @param  hours       Estimated duration in hours of the session</span>
00528 <span class="comment">     *</span>
00529 <span class="comment">     *  @param  minutes     Estimated duration in minutes of the session</span>
00530 <span class="comment">     *</span>
00531 <span class="comment">     */</span>
00532     function pinitialize($hours=12, $minutes=0)
00533     {
00534         global <a class="code" href="grid__test_8php.html#a0">$debug</a>;
00535 
00536         $total_minutes = ($hours * 60) + ($minutes);
00537         <span class="keywordflow">if</span> ($total_minutes &lt; 0) {
00538             <span class="comment">//use default</span>
00539             $hours = 12;
00540             $minutes = 0;
00541         } <span class="keywordflow">else</span> {
00542             $hours = floor($total_minutes / 60);
00543             $minutes = $total_minutes % 60);
00544         }
00545 
00546         <span class="keywordflow">if</span> ($this-&gt;connected == FALSE)
00547                 $this-&gt;connect();
00548         
00549         <span class="comment">// Remote EGEE middleware interaction</span>
00550         <span class="comment">// We run the Globus and Middleware commands in the User Interface, but </span>
00551         <span class="comment">// the output goes to the remote machine in the current directory</span>
00552         fwrite($this-&gt;std_in, <span class="stringliteral">"grid-proxy-init  -pwstdin -valid $hours:$minutes\n"</span>);
00553         fflush($this-&gt;std_in);
00554         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a0">$debug</a>) {
00555             echo fgets($this-&gt;std_out, 1024).<span class="stringliteral">"&lt;p&gt;\n"</span>;   <span class="comment">// last (should have been eaten</span>
00556                                                     <span class="comment">// by connect() )</span>
00557             echo fgets($this-&gt;std_out, 1024).<span class="stringliteral">"&lt;p&gt;\n"</span>;   <span class="comment">// command</span>
00558             echo fgets($this-&gt;std_out, 1024).<span class="stringliteral">"&lt;p&gt;\n"</span>; <span class="comment">// whoami</span>
00559         } <span class="keywordflow">else</span> {
00560             fgets($this-&gt;std_out, 1024);        <span class="comment">// this one should not be needed</span>
00561             fgets($this-&gt;std_out, 1024);
00562             fgets($this-&gt;std_out, 1024);
00563         }
00564         fwrite($this-&gt;std_in, <span class="stringliteral">"$this-&gt;passphrase\n"</span>);
00565         fflush($this-&gt;std_in);
00566         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a0">$debug</a>) {
00567                 echo<span class="stringliteral">"&lt;p&gt;&lt;hr&gt;&lt;p&gt;"</span>;
00568                 echo fgets($this-&gt;std_out, 1024).<span class="stringliteral">"&lt;p&gt;"</span>; <span class="comment">// password</span>
00569                 echo fgets($this-&gt;std_out, 1024).<span class="stringliteral">"&lt;p&gt;"</span>; <span class="comment">// creating...</span>
00570                 echo fgets($this-&gt;std_out, 1024).<span class="stringliteral">"&lt;p&gt;"</span>; <span class="comment">// validity</span>
00571         } <span class="keywordflow">else</span> {
00572             fgets($this-&gt;std_out, 1024);    <span class="comment">// remove passphrase from std_out</span>
00573 <span class="comment">//          fgets($this-&gt;std_out, 1024);</span>
00574 <span class="comment">//          fgets($this-&gt;std_out, 1024);</span>
00575         }
00576         <span class="comment">// The output from grid-proxy-init will go to the session log</span>
00577         <span class="comment">// in std_out</span>
00578         <span class="comment">// Make sure it is read or the child may block on writing.</span>
00579         
00580     }
00581 <span class="comment"></span>
00582 <span class="comment">    /**</span>
00583 <span class="comment">     *  Destroy remote grid identity</span>
00584 <span class="comment">     *</span>
00585 <span class="comment">     *  We destroy the certification we initialized so that no more jobs</span>
00586 <span class="comment">     *  can be launched under our identity.</span>
00587 <span class="comment">     *</span>
00588 <span class="comment">     *  @param pipes    The set of pipes to communicate (stdin/stdout) with</span>
00589 <span class="comment">     *                  the remote grid server entry point</span>
00590 <span class="comment">     */</span>
00591     function pdestroy()
00592     {
00593         global <a class="code" href="grid__test_8php.html#a0">$debug</a>;
00594         fwrite($this-&gt;std_in, <span class="stringliteral">"grid-proxy-destroy\n"</span>);
00595         fflush($this-&gt;std_in);
00596         
00597         <span class="comment">// The output from grid-proxy-destroy will go to the session log</span>
<a name="l00598"></a><a class="code" href="classGrid.html#a11">00598</a>         <span class="comment">// in std_out. There should be none.</span>
00599         <span class="comment">// Make sure it is read or the child may block on writing.</span>
00600 
00601     }
00602 
00603     <span class="comment">// J O B    M A N I P U L A T I O N</span>
00604     <span class="comment">// For the moment these are just stubs to be filled in</span>
00605     <span class="comment">//</span>
00606     <span class="comment"></span>
00607 <span class="comment">    /**</span>
00608 <span class="comment">     * Submit a job to the Grid</span>
00609 <span class="comment">     *</span>
00610 <span class="comment">     * @note STUB. DO NOT USE YET</span>
00611 <span class="comment">     */</span>
00612     function pjob_submit($job)
00613     {
00614         global <a class="code" href="grid__test_8php.html#a0">$debug</a>;
00615         
00616         <span class="comment">// Take a job package and submit it to the Grid</span>
00617         <span class="comment">//  Job package:</span>
00618         <span class="comment">//      everything needed to run the job</span>
00619         <span class="comment">//</span>
00620         <span class="comment">// 1. copy the job package to the grid server</span>
00621         
00622         fwrite($this-&gt;std_in, <span class="stringliteral">"mkdir -p $this-&gt;work_dir\n"</span>);
00623         fflush($this-&gt;std_in);
00624         <span class="comment">// Note: the following will prompt for a password, needs refining!</span>
00625         passthru(<span class="stringliteral">"scp -rpqC $job $this-&gt;entry_point:$this-&gt;work_dir\n"</span>, $status);
00626         <span class="keywordflow">if</span> (<a class="code" href="results_8php.html#a2">$status</a> &gt; 0)
00627             letal(<span class="stringliteral">"Job submission"</span>, <span class="stringliteral">"Can't copy job to Grid server"</span>);
00628         
00629         <span class="comment">// set real job name:</span>
00630         <span class="comment">//  we might have got a long pathname for the job</span>
00631         <span class="comment">//  scp will only copy the last element of the path, which is OK</span>
00632         <span class="comment">//  but we must be sure we use that portion as well for the</span>
00633         <span class="comment">//  remote directory name</span>
00634         $job = basename($job);
00635         
00636         <span class="comment">// 2. submit job to the grid</span>
00637         <span class="comment">// we may need to issue a fwrite($this-&gt;std_in, "cd $this-&gt;work_dir\n");</span>
00638         fwrite($this-&gt;std_in, <span class="stringliteral">"edg-job-submit"</span>
00639                             . <span class="stringliteral">"  -o $this-&gt;work_dir/$job/job.id"</span>
00640                             . <span class="stringliteral">"  $this-&gt;work_dir/$job/job.jdl"</span>
00641                             . <span class="stringliteral">"  &gt; $this-&gt;work_dir/$job/job-info.out\n"</span>);
00642         fflush($this-&gt;std_in);
00643         
00644         <span class="comment">/* This might be used for local files, not remote ones</span>
00645 <span class="comment">        return preg_grep("/^https:/", file("$this-&gt;work_dir/$job/job.id"));</span>
00646 <span class="comment">        * Alternately, we might test for completion of edg-job-submit and</span>
00647 <span class="comment">        * then scp those files back to user's home host and then use the</span>
00648 <span class="comment">        * local code above.</span>
00649 <span class="comment">        */</span>
00650         <span class="keywordflow">return</span>;
00651     }
00652     
00653 
00654     function pjob_get_id($job)
00655     {
00656         <span class="comment">// XXX first we should check that job.id exists</span>
<a name="l00657"></a><a class="code" href="classGrid.html#a12">00657</a>         <span class="comment">// there are two possible scenarios:</span>
00658         <span class="comment">//  mistake - we are called without first calling job_submit</span>
00659         <span class="comment">//  correct - we are called after job_submit: then</span>
00660         <span class="comment">//      - job_submit has completed -- job.id exists</span>
00661         <span class="comment">//      - job_submit has NOT completed -- job.id does'n exist yet</span>
00662         <span class="comment">//        but job-info.out does</span>
00663         
00664         <span class="comment">// check submit.out exists: if not, then warn user</span>
00665         
00666         <span class="comment">// check job.id exists: if not wait/warn user</span>
00667 
00668         <span class="comment">// we may have received a long pathname, but only care about</span>
00669         <span class="comment">// its last component remotely</span>
00670         $remote_dir = basename($job);
00671         passthru(<span class="stringliteral">"scp -C $this-&gt;work_dir/$remote_dir/job.id $job"</span>, $status);
00672         <span class="keywordflow">if</span> (<a class="code" href="results_8php.html#a2">$status</a> &gt; 0) {
00673             <span class="comment">// this is a warning since job-submit may not have finished yet</span>
00674             warning(<span class="stringliteral">"Get job ID: could not retrieve grid job ID"</span>);
00675             <span class="keywordflow">return</span>;
00676         }
00677         <span class="keywordflow">else</span> {
<a name="l00678"></a><a class="code" href="classGrid.html#a13">00678</a>             <span class="keywordflow">return</span> preg_grep(<span class="stringliteral">"/^https:/"</span>, file(<span class="stringliteral">"$job/job.id"</span>));
00679         }
00680         <span class="keywordflow">return</span>; <span class="comment">// empty</span>
00681     }
00682 <span class="comment"></span>
00683 <span class="comment">    /**</span>
00684 <span class="comment">     * check job status</span>
00685 <span class="comment">     *</span>
00686 <span class="comment">     * @note STUB. DO NOT USE YET</span>
00687 <span class="comment">     */</span>
00688     function pjob_status($job)
00689     {
00690         $rjob = basename($job);
00691         $job_id = $this-&gt;job_get_id($rjob);
00692         fwrite($this-&gt;std_in, <span class="stringliteral">"edg-job-status $job_id &gt; $this-&gt;work_dir/$rjob/job.stat\n"</span>);
00693         fflush($this-&gt;std_out);
00694 <span class="comment">//...</span>
00695     }
00696     <span class="comment"></span>
00697 <span class="comment">    /**</span>
00698 <span class="comment">     * retrieve results</span>
00699 <span class="comment">     *</span>
00700 <span class="comment">     * @note STUB. DO NOT USE YET</span>
00701 <span class="comment">     */</span>
00702     function pjob_retrieve($job)
00703     {
00704         <span class="comment">// get output pack ... </span>
00705         passthru(<span class="stringliteral">"scp $this-&gt;entry_point:$work_dir/$job/output.tgz ."</span>, $status);
00706         passthru(<span class="stringliteral">"tar -zxvf output.tgz"</span>, $status);
00707     }
00708 }
00709 
00710 
00711 <span class="comment">//------ S T A N D A L O N E   G R I D   A C C E S S   F U N C T I O N S ------</span>
00712 <span class="comment"></span>
00713 <span class="comment">    /**</span>
00714 <span class="comment">     * Start the Grid services</span>
00715 <span class="comment">     *</span>
00716 <span class="comment">     *  This function starts the grid services on the remote UI server host.</span>
00717 <span class="comment">     *  This is done by unlocking the certificate that we are going to use </span>
00718 <span class="comment">     *  to run our jobs on the grid using the passphrase provided.</span>
00719 <span class="comment">     *</span>
<a name="l00720"></a><a class="code" href="classGrid.html#a14">00720</a> <span class="comment">     *  Grid services have a lifetime of their own. By default they are</span>
00721 <span class="comment">     *  available for 12:00 hours (that's the default value of</span>
00722 <span class="comment">     *  grid-proxy-init itself), but their duration may be fine tuned</span>
00723 <span class="comment">     *  if we have some knowledge about the time required to run our</span>
00724 <span class="comment">     *  job.</span>
00725 <span class="comment">     *</span>
00726 <span class="comment">     *  Session duration is specified in hours+minutes. If the number of</span>
00727 <span class="comment">     *  minutes is negative, the specified minutes are substracted from</span>
00728 <span class="comment">     *  the specified hours (e.g: 1, -15 is fifteen minutes to one hour,</span>
00729 <span class="comment">     *  i.e. 45 minutes). If the total time specified is negative then</span>
00730 <span class="comment">     *  the default of 12:00 is used.</span>
00731 <span class="comment">     *</span>
00732 <span class="comment">     *  @param  hours       Estimated duration in hours of the session</span>
00733 <span class="comment">     *</span>
00734 <span class="comment">     *  @param  minutes     Estimated duration in minutes of the session</span>
00735 <span class="comment">     *</span>
00736 <span class="comment">     *  @return TRUE on success, FALSE otherwise</span>
00737 <span class="comment">     */</span>
00738      
00739     function <a class="code" href="grid_8php.html#a0">initialize</a>($hours=12, $minutes=0)
00740     {
00741         $total_minutes = ($hours * 60) + ($minutes);
00742         <span class="keywordflow">if</span> ($total_minutes &lt; 0) {
00743             <span class="comment">//use default</span>
00744             $hours = 12;
00745             $minutes = 0;
00746         } <span class="keywordflow">else</span> {
00747             $hours = floor($total_minutes / 60);
00748             $minutes = $total_minutes % 60);
00749         }
00750         
00751         $remote = <a class="code" href="classSExec.html#a9">SExec::ssh_popen</a>(<span class="stringliteral">"grid-proxy-init -pwstdin -valid $hours:$minutes"</span>, <span class="stringliteral">"w"</span>);
00752         fputs($remote, $this-&gt;passphrase);
00753         <a class="code" href="results_8php.html#a2">$status</a> <a class="code" href="classSExec.html#a7">SExec::ssh_close</a>($remote);
<a name="l00754"></a><a class="code" href="classGrid.html#a15">00754</a>         <span class="keywordflow">if</span> (<a class="code" href="results_8php.html#a2">$status</a> == 0) {
00755             <span class="keywordflow">return</span> $this-&gt;initialized = TRUE;
00756         } <span class="keywordflow">else</span> {
00757             <span class="keywordflow">return</span> $this-&gt;initialized = FALSE;
00758         }
00759     }
00760 <span class="comment"></span>
00761 <span class="comment">    /**</span>
00762 <span class="comment">     *  Destroy remote grid identity</span>
00763 <span class="comment">     *</span>
00764 <span class="comment">     *  We destroy the certification we initialized so that no more jobs</span>
00765 <span class="comment">     *  can be launched under our identity.</span>
00766 <span class="comment">     *</span>
00767 <span class="comment">     *  @note   Be careful when using this function: as it destroys our</span>
<a name="l00768"></a><a class="code" href="classGrid.html#a16">00768</a> <span class="comment">     *          Grid-ID, no more work will be able to be executed on the</span>
00769 <span class="comment">     *          grid on our behalf. In other words, please, make sure there</span>
00770 <span class="comment">     *          is no work pending and that all your work has terminated</span>
00771 <span class="comment">     *          before destroying your Grid-ID.</span>
00772 <span class="comment">     *</span>
00773 <span class="comment">     *  @param pipes    The set of pipes to communicate (stdin/stdout) with</span>
00774 <span class="comment">     *                  the remote grid server entry point</span>
00775 <span class="comment">     *</span>
00776 <span class="comment">     *  @return exit status of the destroy command.</span>
00777 <span class="comment">     */</span>
00778     function <a class="code" href="grid_8php.html#a1">destroy</a>()
00779     {
00780         <span class="keywordflow">return</span> <a class="code" href="classSExec.html#a3">SExec::ssh_exec</a>(<span class="stringliteral">"grid-proxy-destroy"</span>);
00781     }
00782 <span class="comment"></span>
00783 <span class="comment">    /**</span>
00784 <span class="comment">     * submit a job to the grid</span>
00785 <span class="comment">     */</span>
00786     function <a class="code" href="grid_8php.html#a2">job_submit</a>($job, &amp;$out)
00787     {
00788         <span class="keywordflow">if</span> (isset($out)) {
00789             <span class="comment">// we can report back job execution in detail</span>
00790             <a class="code" href="results_8php.html#a2">$status</a> = <a class="code" href="classSExec.html#a3">SExec::ssh_exec</a>(<span class="stringliteral">"mkdir -p $this-&gt;work_dir"</span>, $output);
00791             $out .= $output;
00792             <span class="keywordflow">if</span> (<a class="code" href="results_8php.html#a2">$status</a> != 0) {
00793                 <span class="comment">// something went wrong</span>
00794                 <span class="keywordflow">return</span> FALSE; 
00795             }
00796             <a class="code" href="results_8php.html#a2">$status</a> = <a class="code" href="classSExec.html#a4">SExec::ssh_copy</a>($job, $this-&gt;entry_point:$this-&gt;work_dir)
00797     }
00798 
00799 ?&gt;
00800 
00801 </pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue May 24 12:14:31 2005 for GridGRAMM by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > </a>1.3.6 </small></address>
</body>
</html>
