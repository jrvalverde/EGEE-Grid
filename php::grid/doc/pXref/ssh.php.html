<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
    <title>PHPXRef 0.4.1 : phpGrid : Detail view of ssh.php</title>
    <link rel="stylesheet" href="/opt/tools/phpxref-0.4.1/sample.css" type="text/css">
    <link rel="stylesheet" href="/opt/tools/phpxref-0.4.1/sample-print.css" type="text/css" media="print">
    <meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
</head>
<body bgcolor="#ffffff" text="#330505" link="#801800" vlink="#300540" alink="#ffffff">
<table class="pagetitle" width="100%">
	<tr>
        <td valign="top" class="pagetitle">
            [ <a href="index.html">Index</a> ]
        </td>
        <td align="right" class="pagetitle">
		    <h2 style="margin-bottom: 0px">PHP Cross Reference of phpGrid</h2>
	    </td>
    </tr>
</table>


<!-- Generated by PHPXref 0.4.1 at Thu Jun 22 10:01:12 2006 -->
<!-- PHPXref (c) 2000-2003 Gareth Watts - gareth@omnipotent.net -->
<!-- http://phpxref.sourceforge.net/ -->

<script src="phpxref.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
ext='.html';
relbase='';
subdir='';
filename='ssh.php.html';
handleNavFrame(relbase, subdir, filename);
// -->
</script>
<script language="JavaScript" type="text/javascript">
if (gwGetCookie('xrefnav')=='off')
  document.write('<p class="navlinks">[ <a href="javascript:navOn()">Show Explorer<\/a> ]<\/p>');
else
  document.write('<p class="navlinks">[ <a href="javascript:navOff()">Hide Explorer<\/a> ]<\/p>');
</script>
<noscript>
<p class="navlinks">
[ <a href="nav.html" target="_top">Show Explorer</a> ]
[ <a href="index.html" target="_top">Hide Navbar</a> ]
</p>
</noscript>
<script language="JavaScript" type="text/javascript">
<!--
function pesc(str) {
    str=str.replace(/^(con|prn|aux|clock\1nul|lpt\d|com\d)$/i, "-$1");
    str=str.replace(/^(con|prn|aux|clock\1nul|lpt\d|com\d)\./i, "-$1.");
    return str;
}
function jump() {
    if (document.search.classname.value.length) {
		classname=document.search.classname.value.replace(/[()]/g,'');
		classname=document.search.classname.value.toLowerCase();
        window.location=relbase+'_classes/'+escape(escape(pesc(classname)))+ext;
	}
    if (document.search.funcname.value.length) {
		funcname=document.search.funcname.value.replace(/[()]/g,'');
		funcname=document.search.funcname.value.toLowerCase();
        window.location=relbase+'_functions/'+escape(escape(pesc(funcname)))+ext;
	}
    if (document.search.varname.value.length) {
		varname=document.search.varname.value.replace(/[$]/g,'');
        window.location=relbase+'_variables/'+escape(escape(pesc(varname)))+ext;
	}
    if (document.search.tablename.value.length) {
		tablename=document.search.tablename.value.toLowerCase();
        window.location=relbase+'_tables/'+escape(escape(pesc(tablename)))+ext;
	}
    return false;
}

document.writeln('<table align="right" border="0" cellspacing="0" cellpadding="0" class="searchbox">');
document.writeln('<tr><td class="searchbox-title">');
document.writeln('Lookup');
document.writeln('<\/td><\/tr>');

document.writeln('<tr><td class="searchbox-body">');
document.writeln('<form name="search" style="margin:0px; padding:0px" onSubmit=\'return jump()\'>');
document.writeln('<a class="searchbox-body" href="_classes/index.html">Class<\/a>: ');
document.writeln('<input type="text" size=10 value="" name="classname" onChange=\'jump()\'><br>');
document.writeln('<a class="searchbox-body" href="_functions/index.html">Function<\/a>: ');
document.writeln('<input type="text" size=10 value="" name="funcname" onChange=\'jump()\'><br>');
document.writeln('<a class="searchbox-body" href="_variables/index.html">Variable<\/a>: ');
document.writeln('<input type="text" size=10 value="" name="varname" onChange=\'jump()\'><br>');
document.writeln('<a class="searchbox-body" href="_tables/index.html">Table<\/a>: ');
document.writeln('<input type="text" size=10 value="" name="tablename" onChange=\'jump()\'>');
document.writeln('<\/form>');
document.writeln('<\/td><\/tr><\/table>');
// -->
</script>
<div class="details-summary">
<h2><a href="./index.html">/</a> -> <a href="ssh.php.source.html">ssh.php</a> (summary)</h2>
<p class="viewlinks">[<a href="ssh.php.source.html">Source view</a>]
[<a href="javascript:window.print();">Print</a>]</p>
<p><b>ssh.php -- a class to execute remote commands over SSH This file contains the files-based implementation of the SExec class. This implementation relies on the usage of regular temporary files to communicate with the remote end, thus avoiding several drawbacks (mainly deadlocks) associated with pipes.</b></p>
<table>
<tr><td align="right">Author: </td><td> 	José R. Valverde <jrvalverde@acm.org></td></tr>
<tr><td align="right">File Size: </td><td>1309 lines (48 kb)</td></tr>
<tr><td align="right">Included or required: </td><td>3 times</td></tr>
<tr><td align="right" valign="top">Referenced: </td><td>0 times</td></tr>
<tr><td align="right" valign="top">Includes or requires: </td><td>1 file<br>&nbsp;<a href="ssh.php.html">ssh.php</a>
</td></tr>
</table>
<h3>Defines 1 class</h3>
<div class="inset">
<p><b>sexec::</b> (13 methods):<br>
&nbsp;&nbsp;<a href="#sexec">sexec</a>()<br>
&nbsp;&nbsp;<a href="#destruct">destruct</a>()<br>
&nbsp;&nbsp;<a href="#ssh_copy">ssh_copy</a>()<br>
&nbsp;&nbsp;<a href="#ssh_copy_to">ssh_copy_to</a>()<br>
&nbsp;&nbsp;<a href="#ssh_copy_from">ssh_copy_from</a>()<br>
&nbsp;&nbsp;<a href="#ssh_passthru">ssh_passthru</a>()<br>
&nbsp;&nbsp;<a href="#ssh_exec">ssh_exec</a>()<br>
&nbsp;&nbsp;<a href="#ssh_open_shell">ssh_open_shell</a>()<br>
&nbsp;&nbsp;<a href="#ssh_open_command">ssh_open_command</a>()<br>
&nbsp;&nbsp;<a href="#ssh_out_expect">ssh_out_expect</a>()<br>
&nbsp;&nbsp;<a href="#ssh_close">ssh_close</a>()<br>
&nbsp;&nbsp;<a href="#ssh_popen">ssh_popen</a>()<br>
&nbsp;&nbsp;<a href="#ssh_pclose">ssh_pclose</a>()<br>
</p>
</div>
</div>
<br><div class="details-funclist">
<div class="details-classinfo">
<p class="details-classtitle">Class: <a name="sexec"><b>sexec</b></a>&nbsp;&nbsp;- <a href="_classes/sexec.html"><small>X-Ref</small></a>
</p>
<b>Allow for remote execution of commands using SSH<BR>
</b><br>
The SExec class provides a number of facilities for remote<BR>
command execution using SSH.<BR>
<BR>
The name SExec comes after &quot;rexec&quot; (the remote execution library)<BR>
and the &quot;exec&quot; facilities available under PHP. As a matter of fact,<BR>
we try to mimic to some extent the execution facilities offered by<BR>
PHP over SSH: thus you will find ssh_popen() akin to popen(), etc.<BR>
<BR>
&lt;b&gt;RATIONALE&lt;/b&gt;<BR>
<BR>
The reason for this class is to allow executing code on a remote<BR>
back-end avoiding MITM spoofs in your communications. This allows you<BR>
to provide a web front-end (possibly redundant) and call a remote<BR>
back-end to execute the job.<BR>
<BR>
Furthermore, you may have fallback features where if execution<BR>
on a remote back-end fails you can restart the command on a fallback<BR>
remote host, increasing reliability.<BR>
<BR>
&lt;b&gt;DEPENDENCIES&lt;/b&gt;<BR>
<BR>
The class relies on an underlying installation of SSH. It has<BR>
been tested with OpenSSH on Linux, but should work on other systems<BR>
with OpenSSH as well.<BR>
<BR>
Further, the class in its current inception relies on OpenSSH<BR>
version being greater than 3.8. If you have an older SSH, please use<BR>
version 1.0 of this class instead.<BR>
<BR>
&lt;b&gt;DESIGN RATIONALE&lt;/b&gt;<BR>
<BR>
The reasons for the choices taken are simple: we might have<BR>
relied on an SSH library (like libSSH) and integrated it with PHP,<BR>
but then, any weakness/bug/change on said library would require a<BR>
recompilation of the library and PHP. This is a serious inconvenience.<BR>
More to that, it would require the maintenance of two simultaneous<BR>
SSH installations, viz. OpenSSH and the library, duplicating the work<BR>
of tracking security/bug issues.<BR>
<BR>
By using the underlying SSH commands, we become independent of<BR>
them: if anything is discovered, you just have to update your system<BR>
SSH, and nothing else. Otherwise you would have a dependency on SSH<BR>
to remember, which is always forgotten. This way we avoid getting out<BR>
of sync with the system's SSH.<BR>
<BR>
Better yet: this easies development, making this class a lot<BR>
simpler to write, understand, maintain and debug.<BR>
<BR>
Finally, the dependency on SSH being OpenSSH 3.8 or greater is<BR>
due to efficiency reasons. Establishing an SSH connection is costly<BR>
in time. If you are going to make many, this would impose a heavy<BR>
cost on your scripts. We routinely launch several thousand remote<BR>
jobs, and authentication delays soon proved unacceptable.<BR>
<BR>
OpenSSH 3.8 introduced the possibility of sharing a single SSH<BR>
channel between many &quot;connections&quot;. This means that only the first<BR>
(or master) instance (which will provide the shared channel) needs<BR>
to authenticate, hence saving significant time.<BR>
<BR>
The constructor then creates a master channel, leaves it idle<BR>
all the object's lifetime and closses it at the end. This channel<BR>
might be used as well, but we felt it wasn't such a big loss to keep<BR>
it idle, and furthermore, being the master, we didn't want to risk<BR>
getting into any trouble that might close it prematurely. So it stands.<BR>
<BR>
All other routines (which actually do the work) simply hijack on<BR>
the master channel, hence avoiding the costly authentication step (and<BR>
executing significantly faster). The only exception are the &quot;COPY&quot;<BR>
routines, which can not hijack the master channel and hence must do<BR>
authentication every time.<BR>
<BR>
One more detail: some methods allow for interactive communication<BR>
with the remote end. We have simply used a terminal-less connection<BR>
for them, using regular files as the intermediate communication channels.<BR>
A pipe implementation is also possible, and works as well, but we have<BR>
found that dealing with pipes is tricky and error-prone, while using<BR>
files is simple and intuitive, so we opted for using files.<BR>
<BR>
The difference has to do with the way you communicate with the<BR>
other end: using pipes you may block on read and/or write, and so<BR>
may the other end. Since there may occur errors in the process, that<BR>
implies that getting into a deadlock is trivial. Just picture this<BR>
scenarios:<BR>
<BR>
You send a command -&gt; the remote ends starts the command and<BR>
prompts for input on stdout, hangs reding on stdin -&gt; you read the<BR>
prompt and send the input -&gt; the remote end wakes and processes it.<BR>
<BR>
You send a command -&gt; the remote end fails, logs an error on<BR>
stderr, gets back the system prompt and hangs on reading stdin -&gt; you<BR>
notice the prompt and read stderr... since you can't predict the<BR>
length of the error message you must empty the pipe... and when doing it<BR>
you hang after reading the last char... -&gt; deadlock<BR>
<BR>
You send a command -&gt; the remote end fails, logs an error on stderr,<BR>
gets back the system prompt and hangs on reading stdin -&gt; you don't read<BR>
stderr to avoid hanging, so submit a new command... this goes on and on<BR>
until the remote side's stderr buffer fills, then the remote side locks<BR>
waiting for you to read stderr -&gt; you can't know it hang, so you try<BR>
to submit a new command, and hang on writing waiting for the other end<BR>
to read your command -&gt; deadlock<BR>
<BR>
More scenarios are possible, and since you (or the other side)<BR>
can't predict what's going to happen, it is very tricky to avoid them.<BR>
<BR>
Now, using files, you don't have that problem: whenever you reach<BR>
the current end-of-file, you get an EOF, no need to hang waiting for<BR>
the other side to fill it in with data. The other side doesn't hang on<BR>
writing unless your disk space fills up. It's a lot simpler.<BR>
<BR>
Your problem with files is continuing reads after new data becomes<BR>
available: the safest way is to call flush() before reading and seeking<BR>
to the last position read to avoid having to re-read everything (which<BR>
implies that after finishing reading you must ftell() your position.<BR>
<BR>
See the included test script for examples.<BR>
<BR>
&lt;b&gt;CUSTOMIZATION&lt;/b&gt;<BR>
<BR>
You &lt;i&gt;must&lt;/i&gt; state to the class where your SSH executables (ssh and<BR>
scp) are located. This allows you to have them placed anywhere, but<BR>
also implies the responsability of using full pathnames to reduce<BR>
hacking dangers. It also allows you to use/test a new SSH implementation<BR>
installed in a non-standard place before switching to it, or even to<BR>
keep various SSH installations on the system (e.g. if the system's<BR>
SSH is not up-to-date, you may install one on your home and use it).<BR>
<BR>
You may also indicate where to store temporary files. This must<BR>
be a directory followed by a prefix to use when creating a temporal<BR>
directory. The parent directory must be writeable by the user who runs<BR>
the class (usually it will be run by apache, www or some such). Most commonly<BR>
the parent directory will be /tmp or $DocumentRoot/tmp or something similar.<BR>
<BR>
The directory+prefix you state will be used to create a unique<BR>
temporary work directory for each object instantiated. Examples of<BR>
a valid specifications are &quot;/tmp/phpSsh-&quot; or &quot;/tmp/&quot;. When the object is<BR>
instantiated, a random string will be appended to this value to create<BR>
the actual temporary directory name.<BR>
<BR>
The reason for allowing specifying a prefix is so that debugging<BR>
may be easier by facilitating identification of temporaries generated<BR>
by this class.<BR>
<BR>
&lt;b&gt;DEBUGGING&lt;/b&gt;<BR>
<BR>
The class comes with extensive debugging aids. To enable them,<BR>
just set a global variable called $debug_sexec to TRUE. This will output<BR>
abundant debugging information and leave copies of communication log<BR>
files for your reference.<BR>
<BR>
Additionally, there is a sample demo script that shows how to<BR>
use this class and may help you debug it. This script is included<BR>
in the distribution (or should be) as 'ssh_debug.php'. See notes<BR>
and comments within it for more details.<BR>
<BR>
<div class="inset"><table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="sexec" href="ssh.php.source.html#l374">sexec</a>(<a href="_variables/remote.html">$remote</a>=&quot;localhost&quot;, <a href="_variables/password.html">$password</a>=&quot;xxyzzy&quot;)&nbsp;&nbsp;
<a href="_functions/sexec.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><i>No description</i></td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="destruct" href="ssh.php.source.html#l501">destruct</a>()&nbsp;&nbsp;
<a href="_functions/destruct.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><i>No description</i></td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_copy" href="ssh.php.source.html#l579">ssh_copy</a>(<a href="_variables/origin.html">$origin</a>, <a href="_variables/destination.html">$destination</a>, <a href="_variables/password.html">$password</a>)&nbsp;&nbsp;
<a href="_functions/ssh_copy.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Copy a file or directory from one source to a destination<BR>
</b><BR>This function copies source to dest, where one of them is a<BR>
local filespec and the other a remote filespec of the form<BR>
[user@]host:path<BR>
<BR>
If the original source is a directory, it will be copied<BR>
recursively to destination (hence easing file transfers).<BR>
<BR>
The function returns TRUE on success or FALSE on failure.<BR>
<BR>
&lt;b&gt;EFFICIENCY NOTICE:&lt;/b&gt;<BR>
<BR>
The copy routines use 'scp' to do their actual work. Since<BR>
scp seems to be unable to hitchhike on the master channel,<BR>
we must do authentication for each copy operation (subroutine<BR>
call). These routines are hence a lot more time-expensive<BR>
than all the other ones.<BR>
<BR>
You may want to consider whether you can group several<BR>
copies into one single call to reduce authentication<BR>
overheads.<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_copy_to" href="ssh.php.source.html#l635">ssh_copy_to</a>(<a href="_variables/localpath.html">$localpath</a>, <a href="_variables/remotepath.html">$remotepath</a>, &amp;<a href="_variables/out.html">$out</a>)&nbsp;&nbsp;
<a href="_functions/ssh_copy_to.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Copy a file or directory from a local source to a remote destination<BR>
</b><BR>This function copies source to dest, where first of them is a<BR>
local filespec and then comes a remote filespec as a normal<BR>
system path.<BR>
<BR>
Both, local and remote paths may be absolute or relative.<BR>
<BR>
If the original source is a directory, it will be copied<BR>
recursively to destination (hence easing file transfers).<BR>
<BR>
The function returns TRUE on success or FALSE on failure.<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_copy_from" href="ssh.php.source.html#l752">ssh_copy_from</a>(<a href="_variables/remotepath.html">$remotepath</a>, <a href="_variables/localpath.html">$localpath</a>, &amp;<a href="_variables/out.html">$out</a>)&nbsp;&nbsp;
<a href="_functions/ssh_copy_from.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Copy a file or directory from a remote source to a local destination<BR>
</b><BR>This function copies source to dest, where first of them is a<BR>
remote filespec and then comes a local filespec, both specified<BR>
as normal system paths.<BR>
<BR>
Both, local and remote paths may be absolute or relative.<BR>
<BR>
If the original source is a directory, it will be copied<BR>
recursively to destination (hence easing file transfers).<BR>
<BR>
The function returns TRUE on success or FALSE on failure.<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_passthru" href="ssh.php.source.html#l880">ssh_passthru</a>(<a href="_variables/command.html">$command</a>, &amp;<a href="_variables/status.html">$status</a>)&nbsp;&nbsp;
<a href="_functions/ssh_passthru.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Execute a single command remotely<BR>
</b><BR>Execute a single command remotely using ssh and<BR>
display its output, optionally returning its exit<BR>
status (like passthru)<BR>
<BR>
This function is intended to be used as a one-time<BR>
all-at-once non-interactive execution mechanism which<BR>
will run the command remotely and display its output.<BR>
<BR>
If you try to issue an interactive command using this<BR>
function, all you will get is unneccessary trouble. So<BR>
don't!<BR>
<BR>
This might be done as well using a pipe on /tmp and<BR>
making the command 'cat' the pipe: when ssh runs, it<BR>
runs the command 'cat' on the pipe and hangs on read.<BR>
Then we just need a thread to open the pipe, put the<BR>
password and close the pipe.<BR>
<BR>
This other way the password is never wirtten down.<BR>
But, OTOH, the file life is so ephemeral that most<BR>
of the time it will only exist in the internal system<BR>
cache, so this approach is not that bad either.<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_exec" href="ssh.php.source.html#l934">ssh_exec</a>(<a href="_variables/command.html">$command</a>, &amp;<a href="_variables/out.html">$out</a>)&nbsp;&nbsp;
<a href="_functions/ssh_exec.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Execute a remote command using SSH<BR>
</b><BR>This function sort of mimics rexec(3) using SSH as the transport<BR>
protocol.<BR>
<BR>
The function returns the exit status of the remote command, and<BR>
appends the remote job output to an optional argument.<BR>
<BR>
This function is intended to be used as a one-time<BR>
all-at-once non-interactive execution mechanism which<BR>
will run the command remotely and return its output.<BR>
<BR>
If you try to issue an interactive command using this<BR>
function, all you will get is unneccessary trouble. So<BR>
don't!<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_open_shell" href="ssh.php.source.html#l986">ssh_open_shell</a>()&nbsp;&nbsp;
<a href="_functions/ssh_open_shell.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Open an SSH connection to a remote site with a shell to run<BR>
interactive commands<BR>
</b><BR>Connects to a remote host and opens an interactive shell session<BR>
with NO controlling terminal.<BR>
<BR>
This routine creates communication streams with the remote shell,<BR>
and stores all output (standard and error) of the connection into<BR>
two separate local log files (one for stdout and one for stderr).<BR>
<BR>
Returns a process_control array which contains the process resource<BR>
ID and an the standard file descriptors which the caller may use to<BR>
interact with the remote shell.<BR>
<BR>
The process control array contains:<BR>
<BR>
'process' -- the process resource for the newly created connection<BR>
<BR>
'std_in' -- handle to the standard input of the new connection<BR>
<BR>
'std_out' -- handle to standard output of the new connection<BR>
<BR>
'std_err' -- handle to standard error of the new connection<BR>
<BR>
'stdout_file' -- actual filename of the local log file for the<BR>
new connection standard output<BR>
<BR>
'stderr_file' -- actual filename of the local log file for the<BR>
new connection standard error<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_open_command" href="ssh.php.source.html#l1098">ssh_open_command</a>(<a href="_variables/command.html">$command</a>)&nbsp;&nbsp;
<a href="_functions/ssh_open_command.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Open an SSH connection to run an interactive command on a remote<BR>
site<BR>
</b><BR>Connects to a remote host and runs an interactive command<BR>
with NO controlling terminal.<BR>
<BR>
This routine creates communication streams with the remote shell,<BR>
and stores all output (standard and error) of the connection into<BR>
two separate local log files (one for stdout and one for stderr).<BR>
<BR>
Returns a process_control array which contains the process resource<BR>
ID and an the standard file descriptors which the caller may use to<BR>
interact with the remote shell.<BR>
<BR>
The process control array contains:<BR>
<BR>
'process' -- the process resource for the newly created connection<BR>
<BR>
'std_in' -- handle to the standard input of the new connection<BR>
<BR>
'std_out' -- handle to standard output of the new connection<BR>
<BR>
'std_err' -- handle to standard error of the new connection<BR>
<BR>
'stdout_file' -- actual filename of the local log file for the<BR>
new connection standard output<BR>
<BR>
'stderr_file' -- actual filename of the local log file for the<BR>
new connection standard error<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_out_expect" href="ssh.php.source.html#l1179">ssh_out_expect</a>(<a href="_variables/p.html">$p</a>, <a href="_variables/expr.html">$expr</a>=&quot;^# &quot;)&nbsp;&nbsp;
<a href="_functions/ssh_out_expect.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Get output until we reach a given regular expression<BR>
</b><BR></td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_close" href="ssh.php.source.html#l1214">ssh_close</a>(<a href="_variables/p.html">$p</a>)&nbsp;&nbsp;
<a href="_functions/ssh_close.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Close an SSH interactive session<BR>
</b><BR>This method terminates a previously open interactive remote<BR>
session. It will send a termination notification to the<BR>
remote end, close the connection with control and communication<BR>
streams, and terminate the local control process.<BR>
<BR>
Copies of the log files that contain the output and error<BR>
of the communication are left out for later reference and<BR>
local peruse. If you don't need them any longer, you may<BR>
delete them or just leave them around until the class destructor<BR>
is called (which will remove all session traces),<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_popen" href="ssh.php.source.html#l1271">ssh_popen</a>(<a href="_variables/command.html">$command</a>, <a href="_variables/mode.html">$mode</a>)&nbsp;&nbsp;
<a href="_functions/ssh_popen.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Execute a remote command and keep an unidirectional stream<BR>
contact with it.<BR>
</b><BR>This routine mimics 'popen()' but uses ssh to connect to<BR>
a remote host and run the requested command: in other words,<BR>
it opens a pipe to a remotely executed command. This pipe is<BR>
unidirectional, with the communications direction controlled<BR>
by a method parameter.<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="ssh_pclose" href="ssh.php.source.html#l1293">ssh_pclose</a>(<a href="_variables/f.html">$f</a>)&nbsp;&nbsp;
<a href="_functions/ssh_pclose.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Close a piped remote execution command control pipe.<BR>
</b><BR>This routine accepts as input the handle for the control stream<BR>
of a remote command and closes it, terminating the command as well.<BR>
The handle must be valid and obtained through a call to ssh_popen().<BR>
<BR>
</td></tr></table>

<br>
</div>
</div>

</div>
<!-- A link to the phpxref site in your customized footer file is appreciated ;-) -->
<br><hr>
<table width="100%">
	<tr><td>Generated: Thu Jun 22 10:01:12 2006</td>
	<td align="right"><i>Cross-referenced by <a href="http://phpxref.sourceforge.net/">PHPXref 0.4.1</a></i></td>
	</tr>
</table>
</body></html>
