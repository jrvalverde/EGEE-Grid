<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>php::Grid: ssh.php Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>ssh.php</h1><a href="test_2ssh_8php.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 &lt;?php
00002 
00003 <span class="comment">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */</span>
00004 <span class="comment"></span>
00005 <span class="comment">/**</span>
00006 <span class="comment"> * ssh.php -- a class to execute remote commands over SSH</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *      This file contains the files-based implementation of the SExec</span>
00009 <span class="comment"> * class. This implementation relies on the usage of regular temporary</span>
00010 <span class="comment"> * files to communicate with the remote end, thus avoiding several</span>
00011 <span class="comment"> * drawbacks (mainly deadlocks) associated with pipes.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *      The SExec class provides methods to launch and control jobs and</span>
00014 <span class="comment"> * transfer files over SSH.</span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> * PHP versions 4 and 5</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> * LICENSE:</span>
00019 <span class="comment"> * This library is free software; you can redistribute it and/or</span>
00020 <span class="comment"> * modify it under the terms of the GNU Lesser General Public</span>
00021 <span class="comment"> * License as published by the Free Software Foundation; either</span>
00022 <span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span>
00023 <span class="comment"> * </span>
00024 <span class="comment"> * This library is distributed in the hope that it will be useful,</span>
00025 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00026 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00027 <span class="comment"> * Lesser General Public License for more details.</span>
00028 <span class="comment"> * </span>
00029 <span class="comment"> * You should have received a copy of the GNU Lesser General Public</span>
00030 <span class="comment"> * License along with this library; if not, write to the Free Software</span>
00031 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> * @category    Net</span>
00034 <span class="comment"> * @package     SExec</span>
00035 <span class="comment"> * @author      José R. Valverde &lt;jrvalverde@acm.org&gt;</span>
00036 <span class="comment"> * @copyright   José R. Valverde &lt;jrvalverde@acm.org&gt;</span>
00037 <span class="comment"> * @license     doc/lic/lgpl.txt</span>
00038 <span class="comment"> * @version     CVS: $Id: ssh.php,v 1.3 2005/05/31 14:01:26 netadmin Exp $</span>
00039 <span class="comment"> * @link        http://savannah.cern.ch/projects/GridGRAMM</span>
00040 <span class="comment"> * @see         ssh(1), scp(1)</span>
00041 <span class="comment"> * @since       File available since Release 1.0</span>
00042 <span class="comment"> */</span>
00043 
00044 <span class="comment"></span>
00045 <span class="comment">/** </span>
00046 <span class="comment"> * Allow for remote execution of commands using SSH</span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> *      The SExec class provides a number of facilities for remote</span>
00049 <span class="comment"> * command execution using SSH.</span>
00050 <span class="comment"> *</span>
00051 <span class="comment"> *      The name SExec comes after "rexec" (the remote execution library)</span>
00052 <span class="comment"> * and the "exec" facilities available under PHP. As a matter of fact,</span>
00053 <span class="comment"> * we try to mimic to some extent the execution facilities offered by</span>
00054 <span class="comment"> * PHP over SSH: thus you will find ssh_popen() akin to popen(), etc.</span>
00055 <span class="comment"> *</span>
00056 <span class="comment"> * &lt;b&gt;RATIONALE&lt;/b&gt;</span>
00057 <span class="comment"> *</span>
00058 <span class="comment"> *      The reason for this class is to allow executing code on a remote</span>
00059 <span class="comment"> * back-end avoiding MITM spoofs in your communications. This allows you</span>
00060 <span class="comment"> * to provide a web front-end (possibly redundant) and call a remote</span>
00061 <span class="comment"> * back-end to execute the job.</span>
00062 <span class="comment"> *</span>
00063 <span class="comment"> *      Furthermore, you may have fallback features where if execution</span>
00064 <span class="comment"> * on a remote back-end fails you can restart the command on a fallback</span>
00065 <span class="comment"> * remote host, increasing reliability.</span>
00066 <span class="comment"> *</span>
00067 <span class="comment"> * &lt;b&gt;DEPENDENCIES&lt;/b&gt;</span>
00068 <span class="comment"> *</span>
00069 <span class="comment"> *      The class relies on an underlying installation of SSH. It has</span>
00070 <span class="comment"> * been tested with OpenSSH on Linux, but should work on other systems</span>
00071 <span class="comment"> * with OpenSSH as well.</span>
00072 <span class="comment"> *</span>
00073 <span class="comment"> *      Further, the class in its current inception relies on OpenSSH</span>
00074 <span class="comment"> * version being greater than 3.8. If you have an older SSH, please use</span>
00075 <span class="comment"> * version 1.0 of this class instead.</span>
00076 <span class="comment"> *</span>
00077 <span class="comment"> * &lt;b&gt;DESIGN RATIONALE&lt;/b&gt;</span>
00078 <span class="comment"> *</span>
00079 <span class="comment"> *      The reasons for the choices taken are simple: we might have</span>
00080 <span class="comment"> * relied on an SSH library (like libSSH) and integrated it with PHP,</span>
00081 <span class="comment"> * but then, any weakness/bug/change on said library would require a</span>
00082 <span class="comment"> * recompilation of the library and PHP. This is a serious inconvenience.</span>
00083 <span class="comment"> * More to that, it would require the maintenance of two simultaneous</span>
00084 <span class="comment"> * SSH installations, viz. OpenSSH and the library, duplicating the work</span>
00085 <span class="comment"> * of tracking security/bug issues.</span>
00086 <span class="comment"> *</span>
00087 <span class="comment"> *      By using the underlying SSH commands, we become independent of</span>
00088 <span class="comment"> * them: if anything is discovered, you just have to update your system</span>
00089 <span class="comment"> * SSH, and nothing else. Otherwise you would have a dependency on SSH</span>
00090 <span class="comment"> * to remember, which is always forgotten. This way we avoid getting out</span>
00091 <span class="comment"> * of sync with the system's SSH.</span>
00092 <span class="comment"> *</span>
00093 <span class="comment"> *      Better yet: this easies development, making this class a lot</span>
00094 <span class="comment"> * simpler to write, understand, maintain and debug.</span>
00095 <span class="comment"> *</span>
00096 <span class="comment"> *      Finally, the dependency on SSH being OpenSSH 3.8 or greater is</span>
00097 <span class="comment"> * due to efficiency reasons. Establishing an SSH connection is costly</span>
00098 <span class="comment"> * in time. If you are going to make many, this would impose a heavy</span>
00099 <span class="comment"> * cost on your scripts. We routinely launch several thousand remote </span>
00100 <span class="comment"> * jobs, and authentication delays soon proved unacceptable.</span>
00101 <span class="comment"> *</span>
00102 <span class="comment"> *      OpenSSH 3.8 introduced the possibility of sharing a single SSH</span>
00103 <span class="comment"> * channel between many "connections". This means that only the first</span>
00104 <span class="comment"> * (or master) instance (which will provide the shared channel) needs </span>
00105 <span class="comment"> * to authenticate, hence saving significant time.</span>
00106 <span class="comment"> *</span>
00107 <span class="comment"> *      The constructor then creates a master channel, leaves it idle</span>
00108 <span class="comment"> * all the object's lifetime and closses it at the end. This channel</span>
00109 <span class="comment"> * might be used as well, but we felt it wasn't such a big loss to keep</span>
00110 <span class="comment"> * it idle, and furthermore, being the master, we didn't want to risk</span>
00111 <span class="comment"> * getting into any trouble that might close it prematurely. So it stands.</span>
00112 <span class="comment"> *</span>
00113 <span class="comment"> *      All other routines (which actually do the work) simply hijack on</span>
00114 <span class="comment"> * the master channel, hence avoiding the costly authentication step (and</span>
00115 <span class="comment"> * executing significantly faster). The only exception are the "COPY" </span>
00116 <span class="comment"> * routines, which can not hijack the master channel and hence must do</span>
00117 <span class="comment"> * authentication every time.</span>
00118 <span class="comment"> *</span>
00119 <span class="comment"> *      One more detail: some methods allow for interactive communication</span>
00120 <span class="comment"> * with the remote end. We have simply used a terminal-less connection</span>
00121 <span class="comment"> * for them, using regular files as the intermediate communication channels.</span>
00122 <span class="comment"> * A pipe implementation is also possible, and works as well, but we have</span>
00123 <span class="comment"> * found that dealing with pipes is tricky and error-prone, while using</span>
00124 <span class="comment"> * files is simple and intuitive, so we opted for using files.</span>
00125 <span class="comment"> *</span>
00126 <span class="comment"> *      The difference has to do with the way you communicate with the</span>
00127 <span class="comment"> * other end: using pipes you may block on read and/or write, and so</span>
00128 <span class="comment"> * may the other end. Since there may occur errors in the process, that</span>
00129 <span class="comment"> * implies that getting into a deadlock is trivial. Just picture this</span>
00130 <span class="comment"> * scenarios:</span>
00131 <span class="comment"> *</span>
00132 <span class="comment"> *      You send a command -&gt; the remote ends starts the command and</span>
00133 <span class="comment"> * prompts for input on stdout, hangs reding on stdin -&gt; you read the </span>
00134 <span class="comment"> * prompt and send the input -&gt; the remote end wakes and processes it.</span>
00135 <span class="comment"> *</span>
00136 <span class="comment"> *      You send a command -&gt; the remote end fails, logs an error on</span>
00137 <span class="comment"> * stderr, gets back the system prompt and hangs on reading stdin -&gt; you</span>
00138 <span class="comment"> * notice the prompt and read stderr... since you can't predict the </span>
00139 <span class="comment"> * length of the error message you must empty the pipe... and when doing it</span>
00140 <span class="comment"> * you hang after reading the last char... -&gt; deadlock</span>
00141 <span class="comment"> *</span>
00142 <span class="comment"> *      You send a command -&gt; the remote end fails, logs an error on stderr,</span>
00143 <span class="comment"> * gets back the system prompt and hangs on reading stdin -&gt; you don't read</span>
00144 <span class="comment"> * stderr to avoid hanging, so submit a new command... this goes on and on</span>
00145 <span class="comment"> * until the remote side's stderr buffer fills, then the remote side locks</span>
00146 <span class="comment"> * waiting for you to read stderr -&gt; you can't know it hang, so you try</span>
00147 <span class="comment"> * to submit a new command, and hang on writing waiting for the other end</span>
00148 <span class="comment"> * to read your command -&gt; deadlock</span>
00149 <span class="comment"> *</span>
00150 <span class="comment"> *      More scenarios are possible, and since you (or the other side)</span>
00151 <span class="comment"> * can't predict what's going to happen, it is very tricky to avoid them.</span>
00152 <span class="comment"> *</span>
00153 <span class="comment"> *      Now, using files, you don't have that problem: whenever you reach</span>
00154 <span class="comment"> * the current end-of-file, you get an EOF, no need to hang waiting for</span>
00155 <span class="comment"> * the other side to fill it in with data. The other side doesn't hang on</span>
00156 <span class="comment"> * writing unless your disk space fills up. It's a lot simpler. </span>
00157 <span class="comment"> *</span>
00158 <span class="comment"> *      Your problem with files is continuing reads after new data becomes</span>
00159 <span class="comment"> * available: the safest way is to call flush() before reading and seeking</span>
00160 <span class="comment"> * to the last position read to avoid having to re-read everything (which</span>
00161 <span class="comment"> * implies that after finishing reading you must ftell() your position.</span>
00162 <span class="comment"> *</span>
00163 <span class="comment"> *      See the included test script for examples.</span>
00164 <span class="comment"> *</span>
00165 <span class="comment"> * &lt;b&gt;CUSTOMIZATION&lt;/b&gt;</span>
00166 <span class="comment"> *</span>
00167 <span class="comment"> *      You &lt;i&gt;must&lt;/i&gt; state to the class where your SSH executables (ssh and</span>
00168 <span class="comment"> * scp) are located. This allows you to have them placed anywhere, but</span>
00169 <span class="comment"> * also implies the responsability of using full pathnames to reduce</span>
00170 <span class="comment"> * hacking dangers. It also allows you to use/test a new SSH implementation</span>
00171 <span class="comment"> * installed in a non-standard place before switching to it, or even to</span>
00172 <span class="comment"> * keep various SSH installations on the system (e.g. if the system's</span>
00173 <span class="comment"> * SSH is not up-to-date, you may install one on your home and use it).</span>
00174 <span class="comment"> *</span>
00175 <span class="comment"> *      You may also indicate where to store temporary files. This must </span>
00176 <span class="comment"> * be a directory followed by a prefix to use when creating a temporal</span>
00177 <span class="comment"> * directory. The parent directory must be writeable by the user who runs </span>
00178 <span class="comment"> * the class (usually it will be run by apache, www or some such). Most commonly </span>
00179 <span class="comment"> * the parent directory will be /tmp or $DocumentRoot/tmp or something similar.</span>
00180 <span class="comment"> *</span>
00181 <span class="comment"> *      The directory+prefix you state will be used to create a unique</span>
00182 <span class="comment"> * temporary work directory for each object instantiated. Examples of</span>
00183 <span class="comment"> * a valid specifications are "/tmp/phpSsh-" or "/tmp/". When the object is </span>
00184 <span class="comment"> * instantiated, a random string will be appended to this value to create</span>
00185 <span class="comment"> * the actual temporary directory name.</span>
00186 <span class="comment"> *      </span>
00187 <span class="comment"> *      The reason for allowing specifying a prefix is so that debugging</span>
00188 <span class="comment"> * may be easier by facilitating identification of temporaries generated</span>
00189 <span class="comment"> * by this class.</span>
00190 <span class="comment"> *</span>
00191 <span class="comment"> * &lt;b&gt;DEBUGGING&lt;/b&gt;</span>
00192 <span class="comment"> *</span>
00193 <span class="comment"> *      The class comes with extensive debugging aids. To enable them,</span>
00194 <span class="comment"> * just set a global variable called $debug_sexec to TRUE. This will output</span>
00195 <span class="comment"> * abundant debugging information and leave copies of communication log</span>
00196 <span class="comment"> * files for your reference.</span>
00197 <span class="comment"> *</span>
00198 <span class="comment"> *      Additionally, there is a sample demo script that shows how to</span>
00199 <span class="comment"> * use this class and may help you debug it. This script is included </span>
00200 <span class="comment"> * in the distribution (or should be) as 'ssh_debug.php'. See notes</span>
00201 <span class="comment"> * and comments within it for more details.</span>
00202 <span class="comment"> *</span>
00203 <span class="comment"> * @category    Net</span>
00204 <span class="comment"> * @package     SExec</span>
00205 <span class="comment"> * @author      José R. Valverde &lt;jrvalverde@acm.org&gt;</span>
00206 <span class="comment"> * @copyright   José R. Valverde &lt;jrvalverde@es.embnet.org&gt;</span>
00207 <span class="comment"> * @license     doc/lic/</span>
00208 <span class="comment"> * @version     Release: 2.1</span>
00209 <span class="comment"> * @link        http://savannah.cern.ch/projects/GridGRAMM</span>
00210 <span class="comment"> * @see         ssh(1), scp(1)</span>
00211 <span class="comment"> * @since       File available since Release 1.0</span>
00212 <span class="comment"></span>
00213 <span class="comment"> */</span>
00214 <span class="keyword">class </span>SExec {
00215 
00216     <span class="comment">// {{{ properties</span>
00217 <span class="comment"></span>
00218 <span class="comment">    /**</span>
00219 <span class="comment">     * The current version of the class</span>
00220 <span class="comment">     *</span>
00221 <span class="comment">     * @var string</span>
00222 <span class="comment">     * @access public</span>
00223 <span class="comment">     */</span>
00224     var $version=<span class="stringliteral">"2.2"</span>;
00225     <span class="comment"></span>
00226 <span class="comment">    /**</span>
00227 <span class="comment">     * remote endpoint ([user@]host[:port])</span>
00228 <span class="comment">     *</span>
00229 <span class="comment">     * @var string</span>
00230 <span class="comment">     * @access private</span>
00231 <span class="comment">     */</span>
00232     var $remote;
00233     <span class="comment"></span>
00234 <span class="comment">    /**</span>
00235 <span class="comment">     * remote password </span>
00236 <span class="comment">     *</span>
00237 <span class="comment">     * @var string</span>
00238 <span class="comment">     * @access private</span>
00239 <span class="comment">     */</span>
00240     var $password;
00241 <span class="comment"></span>
00242 <span class="comment">    /**</span>
00243 <span class="comment">     * location of ssh program</span>
00244 <span class="comment">     *</span>
00245 <span class="comment">     * @var string</span>
00246 <span class="comment">     * @access private</span>
00247 <span class="comment">     */</span>
00248     var $ssh = <span class="stringliteral">"/usr/bin/ssh"</span>;
00249     <span class="comment"></span>
00250 <span class="comment">    /**</span>
00251 <span class="comment">     * location of scp program</span>
00252 <span class="comment">     *</span>
00253 <span class="comment">     * @var string</span>
00254 <span class="comment">     * @access private</span>
00255 <span class="comment">     */</span>
00256     var $scp = <span class="stringliteral">"/usr/bin/scp"</span>;
00257     <span class="comment"></span>
00258 <span class="comment">    /**</span>
00259 <span class="comment">     * tmp. dir prefix specification</span>
00260 <span class="comment">     *</span>
00261 <span class="comment">     * @var string</span>
00262 <span class="comment">     * @access private</span>
00263 <span class="comment">     */</span>
00264     var $workdir = <span class="stringliteral">"/tmp/phpSsh"</span>;
00265     <span class="comment"></span>
00266 <span class="comment">    /**</span>
00267 <span class="comment">     * name of multiplexing socket</span>
00268 <span class="comment">     *</span>
00269 <span class="comment">     * @var string</span>
00270 <span class="comment">     * @access private</span>
00271 <span class="comment">     */</span>
00272     var $mplex_socket = <span class="stringliteral">"/tmp/ssh.mplex"</span>;
00273     <span class="comment"></span>
00274 <span class="comment">    /**</span>
00275 <span class="comment">     * handle to process controlling the master channel</span>
00276 <span class="comment">     *</span>
00277 <span class="comment">     * @var string</span>
00278 <span class="comment">     * @access private</span>
00279 <span class="comment">     */</span>
00280     var $master;
00281     <span class="comment"></span>
00282 <span class="comment">    /**</span>
00283 <span class="comment">     * stdin of process controlling the master channel</span>
00284 <span class="comment">     *</span>
00285 <span class="comment">     * @var string</span>
00286 <span class="comment">     * @access private</span>
00287 <span class="comment">     */</span>
00288     var $master_input;
00289 
00290     <span class="comment">//}}}</span>
00291     
00292     <span class="comment">//{{{   instantiation</span>
00293     <span class="comment"></span>
00294 <span class="comment">    /** Class constructor.</span>
00295 <span class="comment">     *</span>
00296 <span class="comment">     *  Generate a new instance of a remote execution environment.</span>
00297 <span class="comment">     * The object returned allows you to invoke commands to be executed</span>
00298 <span class="comment">     * remotely in a way similar to PHP exec commands (popen, proc_open...)</span>
00299 <span class="comment">     * over SSH (so that your communications can be secure).</span>
00300 <span class="comment">     *</span>
00301 <span class="comment">     *  You may specify a remote endpoint and a password, a remote endpoint</span>
00302 <span class="comment">     * alone, or nothing at all.</span>
00303 <span class="comment">     *</span>
00304 <span class="comment">     *  If you provide a remote endpoint and password they are used to drive</span>
00305 <span class="comment">     * the communications and execute your commands.</span>
00306 <span class="comment">     *</span>
00307 <span class="comment">     *  If no password is provided, then a default of "xxyzzy" (the canonical</span>
00308 <span class="comment">     * computer magic word) is used. Unless this is your password (not </span>
00309 <span class="comment">     * recommended), this means that the default password is useless unless</span>
00310 <span class="comment">     * you are working in a trusted environment where it is not needed and</span>
00311 <span class="comment">     * ignored. That may be the case if you enable trusting mechanisms with</span>
00312 <span class="comment">     * .shosts/.rhosts or passphraseless RSA/DSA authentication. Not that</span>
00313 <span class="comment">     * we endorse them either, but in these cases any password provided will</span>
00314 <span class="comment">     * be ignored and it doesn't make sense to provide a real one: xxyzzy</span>
00315 <span class="comment">     * can do as well as any other.</span>
00316 <span class="comment">     *</span>
00317 <span class="comment">     *  If no password and no remote end is provided, then "localhost" is</span>
00318 <span class="comment">     * used as the remote end, assuming no password is required (as described</span>
00319 <span class="comment">     * above). This is only useful if localhost is trusted, and you have reasons</span>
00320 <span class="comment">     * to use SSH internally... Some people does.</span>
00321 <span class="comment">     *</span>
00322 <span class="comment">     *  Regarding the remote end specification, it can be any valid single-string</span>
00323 <span class="comment">     * SSH remote end description: the basic format is</span>
00324 <span class="comment">     *</span>
00325 <span class="comment">     *  [username@]remote.host[:port]</span>
00326 <span class="comment">     *</span>
00327 <span class="comment">     *  - "username" is the remote user name to log in as. It is optional. If provided, </span>
00328 <span class="comment">     *    it must be separated from the remote host by an "@" sign. If it is not </span>
00329 <span class="comment">     *    provided, the remote username is assumed to be the same as the current local</span>
00330 <span class="comment">     *    one.</span>
00331 <span class="comment">     *</span>
00332 <span class="comment">     *  - "remote.host" is a valid host specification, either a numeric IP address</span>
00333 <span class="comment">     *    or a valid host name (which may require a full name or not depending on</span>
00334 <span class="comment">     *    your settings).</span>
00335 <span class="comment">     *</span>
00336 <span class="comment">     *  - "port" is the remote port where SSH is listening and which we want to</span>
00337 <span class="comment">     *    connect to. It is optional, and if provided, must follow the remote host</span>
00338 <span class="comment">     *    specification separated from it by a colon ":". If not provided, the</span>
00339 <span class="comment">     *    default port (22) is used.</span>
00340 <span class="comment">     *</span>
00341 <span class="comment">     *  Examples of remote host specifications are "user@host.example.net:22",</span>
00342 <span class="comment">     * "someone@host:22", "host.example.net:22", "host:22", </span>
00343 <span class="comment">     * "somebody@host.example.net", "user@host", "host.example.net", "host".</span>
00344 <span class="comment">     *</span>
00345 <span class="comment">     * Here is an example of how to use this constructor:</span>
00346 <span class="comment">     * &lt;code&gt;</span>
00347 <span class="comment">     *  require_once 'ssh.php';</span>
00348 <span class="comment">     *</span>
00349 <span class="comment">     *  $remote = "jruser@example.com";</span>
00350 <span class="comment">     *  $password = "PASSWORD";</span>
00351 <span class="comment">     *</span>
00352 <span class="comment">     *  $rmt = new SExec($remote, $password);</span>
00353 <span class="comment">     *   if (! $rmt)</span>
00354 <span class="comment">     *          echo "Couldn't connect to $remote\n";</span>
00355 <span class="comment">     * &lt;/code&gt;</span>
00356 <span class="comment">     *</span>
00357 <span class="comment">     *  @param string   The remote end to run the command, in</span>
00358 <span class="comment">     *                      the form 'user@host:port' (you may</span>
00359 <span class="comment">     *                      omit the 'user@' or ':port' parts</span>
00360 <span class="comment">     *                      if the default values [i.e. same user</span>
00361 <span class="comment">     *                      or standard port] are OK).</span>
00362 <span class="comment">     *</span>
00363 <span class="comment">     *  @param string The remote password. Note that if direct</span>
00364 <span class="comment">     *                      RSA/DSA/.shosts/.rhosts login is enabled</span>
00365 <span class="comment">     *                      then the password will be ignored as</span>
00366 <span class="comment">     *                      SSH should not run the ASKPASS command).</span>
00367 <span class="comment">     *</span>
00368 <span class="comment">     *  @return SExec|false a new connection object with the remote end or</span>
00369 <span class="comment">     *                      FALSE if the connection could not be established.</span>
00370 <span class="comment">     *</span>
00371 <span class="comment">     *  @access public</span>
00372 <span class="comment">     *  @since Method available since Release 1.0</span>
00373 <span class="comment">     */</span>
00374     function <a class="code" href="classSExec.html">SExec</a>($remote=<span class="stringliteral">"localhost"</span>, $password=<span class="stringliteral">"xxyzzy"</span>)
00375     {
00376         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
00377         
00378         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"\nSExec::SExec($remote, $password)\n"</span>;
00379         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt; Creating a new SExec\n"</span>;
00380         $this-&gt;remote = $remote;
00381         $this-&gt;password = <span class="stringliteral">"$password"</span>;
00382         umask(0077);
00383         <span class="comment">/* DESIGN</span>
00384 <span class="comment">         * In order to increase efficiency, we will create a master channel</span>
00385 <span class="comment">         * on class instantiation. The master channel should be closed by a</span>
00386 <span class="comment">         * corresponding class destructor!</span>
00387 <span class="comment">         *</span>
00388 <span class="comment">         * Creating a master channel has the advantage that subsequent SSH</span>
00389 <span class="comment">         * connections will use it and avoid repeating the slow authentication</span>
00390 <span class="comment">         * process: in other words, they will go much, much faster.</span>
00391 <span class="comment">         */</span>
00392          
00393         <span class="comment">// first we must generate a unique UNIX socket address or we'll fail</span>
00394         <span class="comment">// We use a tricky trick: generate two random numbers and use them;</span>
00395         <span class="comment">// this is tricky since there might be a problem, but with very low</span>
00396         <span class="comment">// probability. BUT IT MAY STILL FAIL: there's a race condition between</span>
00397         <span class="comment">// the end of the while and the subsequent if.</span>
00398         <span class="keywordflow">do</span> {
00399             mt_srand((<span class="keywordtype">double</span>)microtime()*1000000 ) .
00400             $this-&gt;workdir = <span class="stringliteral">"/tmp/phpSsh-"</span> . mt_rand() .<span class="stringliteral">"."</span>. mt_rand();
00401             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"\nSExec: trying $this-&gt;workdir/ ..."</span>;
00402             <span class="comment">// CAUTION: this is potentially an endless loop (albeit with very</span>
00403             <span class="comment">// low probability) if every possible file did exist.</span>
00404         }
00405         <span class="keywordflow">while</span> (file_exists($this-&gt;workdir));
00406         <span class="keywordflow">if</span> (mkdir($this-&gt;workdir) == FALSE) {
00407             <span class="comment">// we can't continue. How can we cancel this?</span>
00408             <span class="comment">// try these and then check what happens</span>
00409             unset($<span class="keyword">this</span>);
00410             $this = NULL;
00411             <span class="keywordflow">return</span> FALSE;
00412         }
00413         <span class="keywordflow">else</span> 
00414             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">" OK\n"</span>;
00415         <span class="comment">// Now we have a place to put the socket... Mmm...</span>
00416         <span class="comment">// Come to think of it, we have a place to put ANY temporary</span>
00417         <span class="comment">// for the class... </span>
00418         <span class="comment">// XXX Maybe we can change everywhere else to use this?</span>
00419         $this-&gt;mplex_socket = $this-&gt;workdir.<span class="stringliteral">"/mplex_socket"</span>;
00420         
00421         <span class="comment">// Finally we can call SSH -M</span>
00422         <span class="comment">// Create SSH_ASKPASS script to provide the password</span>
00423         $tmpfname = tempnam($this-&gt;workdir, 'SExec-');
00424         chmod($tmpfname, 0700);
00425         putenv(<span class="stringliteral">"DISPLAY=none:0."</span>);
00426         putenv(<span class="stringliteral">"SSH_ASKPASS=$tmpfname"</span>);
00427         $fp = fopen($tmpfname, <span class="stringliteral">"w"</span>);
00428         fputs($fp, <span class="stringliteral">"#!/bin/sh\necho $this-&gt;password\n"</span>);
00429         <span class="keywordflow">if</span> (!<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) 
00430             fputs($fp, <span class="stringliteral">"/bin/touch $tmpfname.called\n"</span>);
00431         <span class="keywordflow">else</span>
00432             fputs($fp, <span class="stringliteral">"/bin/rm -f $tmpfname\n"</span>);
00433         fclose($fp);
00434         
00435         <span class="comment">// OK, we are ready. Now let's open a master shell</span>
00436         $child_stdout = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-O-"</span>);
00437         $child_stderr = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-E-"</span>);
00438         $descriptorspec = array(
00439             0 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"r"</span>),  <span class="comment">// connect child's stdin to the read end of a pipe</span>
00440             1 =&gt; array(<span class="stringliteral">"file"</span>, $child_stdout, <span class="stringliteral">"a"</span>),  <span class="comment">// connect child's stdout to the write end of a pipe</span>
00441             2 =&gt; array(<span class="stringliteral">"file"</span>, $child_stderr, <span class="stringliteral">"a"</span>)   <span class="comment">// stderr is a pipe to read from</span>
00442         );
00443 
00444         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"$this-&gt;ssh -x -t -t "</span>.
00445                      <span class="stringliteral">"-M -S $this-&gt;mplex_socket "</span> .
00446                      <span class="stringliteral">"$this-&gt;remote\n"</span>;
00447         $this-&gt;master = proc_open(<span class="stringliteral">"$this-&gt;ssh -x -t -t "</span>.
00448                      <span class="stringliteral">"-M -S $this-&gt;mplex_socket "</span> .
00449                      <span class="stringliteral">"$this-&gt;remote"</span>,
00450                      $descriptorspec,
00451                      $pipes);
00452         <span class="keywordflow">if</span> ((! is_resource($this-&gt;master)) || ($this-&gt;master == FALSE)) {
00453                 putenv(<span class="stringliteral">"SSH_ASKPASS=dummy"</span>);
00454                 unset($<span class="keyword">this</span>);
00455                 $this = NULL;
00456                 <span class="keywordflow">return</span> FALSE;
00457         }
00458         <span class="comment">// we do not need to worry about the output log files, just the</span>
00459         <span class="comment">// input pipe for logout</span>
00460         $this-&gt;master_input = $pipes[0];
00461         
00462         <span class="comment">// Before going ahead, we need to ensure the control shell </span>
00463         <span class="comment">// has started: wait for the socket to become available</span>
00464         <span class="comment">// note: there should be a timeout here to avoid a possibly</span>
00465         <span class="comment">// infinite loop XXX JR XXX</span>
00466         <span class="keywordflow">do</span> {
00467             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"waiting 0.1 sec for $this-&gt;mplex_socket\n"</span>;
00468             usleep(100000);     <span class="comment">// wait 0.1 seconds</span>
00469         } <span class="keywordflow">while</span> (! file_exists($this-&gt;mplex_socket));
00470 
00471         <span class="comment">// and now we must register a destructor for the class</span>
00472         <span class="comment">// that will close the connection.</span>
00473         <span class="comment">//register_shutdown_function($this-&gt;destruct());</span>
00474         
00475         <span class="keywordflow">return</span> $this;
00476     }
00477     <span class="comment"></span>
00478 <span class="comment">    /** Class destructor</span>
00479 <span class="comment">     *</span>
00480 <span class="comment">     *  Destroy all working processes and data streams and structures</span>
00481 <span class="comment">     * used by an instance of this class.</span>
00482 <span class="comment">     *</span>
00483 <span class="comment">     *  This method will send a termination message to the other end</span>
00484 <span class="comment">     * of the master channel, close the control stream of the master</span>
00485 <span class="comment">     * channel and terminate its controlling process, finally unsetting</span>
00486 <span class="comment">     * the object and setting the object handle to NULL.</span>
00487 <span class="comment">     *</span>
00488 <span class="comment">     *  If a global $debug_sexec is not set to TRUE, then it will also remove</span>
00489 <span class="comment">     * all communication traces of this object: i.e. all log files for</span>
00490 <span class="comment">     * interactive and master sessions, communications socket, etc...</span>
00491 <span class="comment">     *</span>
00492 <span class="comment">     *  If global $debug_sexec is set to TRUE, then a copy of all log files</span>
00493 <span class="comment">     * created during the lifetime of the object will be left on a</span>
00494 <span class="comment">     * temporary directory for your perusal and reference.</span>
00495 <span class="comment">     *</span>
00496 <span class="comment">     *  @return integer exit status of the master channel control process.</span>
00497 <span class="comment">     *</span>
00498 <span class="comment">     *  @access public</span>
00499 <span class="comment">     *  @since Method available since Release 1.0</span>
00500 <span class="comment">     */</span>
00501     function destruct()
00502     {
00503         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
00504         
00505         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"\nSExec::destruct()\n"</span>;
00506         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt; Destroying SExec master\n"</span>;
00507         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) print_r($<span class="keyword">this</span>);
00508         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"sending logout\n"</span>;
00509         <span class="comment">// log out master process</span>
00510         fputs($this-&gt;master_input, <span class="stringliteral">"\n\nlogout\n\n"</span>);
00511         <span class="comment">// close master stdin</span>
00512         fclose($this-&gt;master_input);
00513         <span class="comment">// close master process</span>
00514         $ret = proc_close($this-&gt;master);
00515         <span class="comment">// remove temporaries</span>
00516         <span class="keywordflow">if</span> (! <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) system(<span class="stringliteral">"/bin/rm -rf $this-&gt;workdir"</span>);
00517         <span class="comment">// utterly destroy this instance</span>
00518         unset($<span class="keyword">this</span>);
00519         $this = NULL;
00520         <span class="keywordflow">return</span> $ret;
00521     }    
00522     
00523     <span class="comment">//}}}</span>
00524     
00525     <span class="comment">//{{{ methods</span><span class="comment"></span>
00526 <span class="comment">    /**</span>
00527 <span class="comment">     *  Copy a file or directory from one source to a destination</span>
00528 <span class="comment">     *</span>
00529 <span class="comment">     *  This function copies source to dest, where one of them is a</span>
00530 <span class="comment">     * local filespec and the other a remote filespec of the form</span>
00531 <span class="comment">     * [user@]host:path</span>
00532 <span class="comment">     *</span>
00533 <span class="comment">     *  If the original source is a directory, it will be copied</span>
00534 <span class="comment">     * recursively to destination (hence easing file transfers).</span>
00535 <span class="comment">     *</span>
00536 <span class="comment">     *  The function returns TRUE on success or FALSE on failure.</span>
00537 <span class="comment">     *</span>
00538 <span class="comment">     * &lt;b&gt;EFFICIENCY NOTICE:&lt;/b&gt;</span>
00539 <span class="comment">     *</span>
00540 <span class="comment">     *  The copy routines use 'scp' to do their actual work. Since</span>
00541 <span class="comment">     * scp seems to be unable to hitchhike on the master channel,</span>
00542 <span class="comment">     * we must do authentication for each copy operation (subroutine </span>
00543 <span class="comment">     * call). These routines are hence a lot more time-expensive </span>
00544 <span class="comment">     * than all the other ones.</span>
00545 <span class="comment">     *</span>
00546 <span class="comment">     *  You may want to consider whether you can group several</span>
00547 <span class="comment">     * copies into one single call to reduce authentication </span>
00548 <span class="comment">     * overheads.</span>
00549 <span class="comment">     *</span>
00550 <span class="comment">     *  @note DEPRECATED (inconsistent with the class)</span>
00551 <span class="comment">     *</span>
00552 <span class="comment">     *  @see scp(1)</span>
00553 <span class="comment">     *</span>
00554 <span class="comment">     *  @param string   The origin path, of the form</span>
00555 <span class="comment">     *                  [user@][host][:port]path</span>
00556 <span class="comment">     *                  You may omit the optional sections if</span>
00557 <span class="comment">     *                  the default values (local username, local</span>
00558 <span class="comment">     *                  host, standard SSH port) are OK</span>
00559 <span class="comment">     *</span>
00560 <span class="comment">     *  @param string   The destination path, of the form</span>
00561 <span class="comment">     *                  [user@][host][:port:]path</span>
00562 <span class="comment">     *                  You may omit the optional sections if</span>
00563 <span class="comment">     *                  the default values (local username, local</span>
00564 <span class="comment">     *                  host, standard SSH port) are OK</span>
00565 <span class="comment">     *</span>
00566 <span class="comment">     *  @param string   The password to use to connect to the remote</span>
00567 <span class="comment">     *                  end of the copy (be it the origin or the</span>
00568 <span class="comment">     *                  destination, it's all the same). If connection</span>
00569 <span class="comment">     *                  is automatic by some means (.shosts or RSA/DSA</span>
00570 <span class="comment">     *                  authentication) then it should be ignored and</span>
00571 <span class="comment">     *                  any password should do.</span>
00572 <span class="comment">     *</span>
00573 <span class="comment">     *  @return bool TRUE if all went well, or FALSE on failure.</span>
00574 <span class="comment">     *</span>
00575 <span class="comment">     *  @access public</span>
00576 <span class="comment">     *  @since Method available since Release 1.0</span>
00577 <span class="comment">     *  @deprecated Method deprecated as of Release 2.1</span>
00578 <span class="comment">     */</span>
00579     function <a class="code" href="test_2util_8php.html#a6">ssh_copy</a>($origin, $destination, $password)
00580     {
00581         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
00582 
00583         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"\nSExec::ssh_copy($origin, $destination, $password)\n"</span>;
00584         umask(0077);
00585         $tmpfname = tempnam($this-&gt;workdir, <span class="stringliteral">"copy-"</span>);
00586         chmod($tmpfname, 0700);
00587         putenv(<span class="stringliteral">"DISPLAY=none:0."</span>);
00588         putenv(<span class="stringliteral">"SSH_ASKPASS=$tmpfname"</span>);
00589         $fp = fopen($tmpfname, <span class="stringliteral">"w"</span>);
00590         fputs($fp, <span class="stringliteral">"#!/bin/sh\necho $password\n"</span>);
00591         <span class="keywordflow">if</span> (! <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>)  
00592             fputs($fp, <span class="stringliteral">"/bin/touch $tmpfname.called\n"</span>);
00593         <span class="keywordflow">else</span>
00594             fputs($fp, <span class="stringliteral">"/bin/rm $tmpfname\n"</span>);
00595         fclose($fp);
00596         $out=<span class="stringliteral">""</span>;
00597         exec(<span class="stringliteral">"$this-&gt;scp -pqrC $origin $destination"</span>, $out, $status);
00598         <span class="keywordflow">if</span> ($status == 0)
00599             <span class="keywordflow">return</span> TRUE;
00600         <span class="keywordflow">else</span>
00601             <span class="keywordflow">return</span> FALSE;
00602     }
00603 
00604 <span class="comment"></span>
00605 <span class="comment">    /**</span>
00606 <span class="comment">     *  Copy a file or directory from a local source to a remote destination</span>
00607 <span class="comment">     *</span>
00608 <span class="comment">     *  This function copies source to dest, where first of them is a</span>
00609 <span class="comment">     * local filespec and then comes a remote filespec as a normal</span>
00610 <span class="comment">     * system path.</span>
00611 <span class="comment">     *</span>
00612 <span class="comment">     *  Both, local and remote paths may be absolute or relative.</span>
00613 <span class="comment">     *</span>
00614 <span class="comment">     *  If the original source is a directory, it will be copied</span>
00615 <span class="comment">     * recursively to destination (hence easing file transfers).</span>
00616 <span class="comment">     *</span>
00617 <span class="comment">     *  The function returns TRUE on success or FALSE on failure.</span>
00618 <span class="comment">     *</span>
00619 <span class="comment">     *  @param string    The origin local path, either absolute or</span>
00620 <span class="comment">     *                  relative to the current working directory. </span>
00621 <span class="comment">     *                  If it denotes a directory, the copy will </span>
00622 <span class="comment">     *                  be recursive.</span>
00623 <span class="comment">     *</span>
00624 <span class="comment">     *  @param string   The destination path, either</span>
00625 <span class="comment">     *                  absolute or relative to the login home.</span>
00626 <span class="comment">     *</span>
00627 <span class="comment">     *  @param array   An optional array of strings to be appended the </span>
00628 <span class="comment">     *                  copy operation's output for debugging/diagnostics.</span>
00629 <span class="comment">     *</span>
00630 <span class="comment">     *  @return bool TRUE if all went well, or FALSE on failure.</span>
00631 <span class="comment">     *</span>
00632 <span class="comment">     *  @access public</span>
00633 <span class="comment">     *  @since Method available since Release 2.1</span>
00634 <span class="comment">     */</span>
00635     function ssh_copy_to($localpath, $remotepath, &amp;$out)
00636     {
00637         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
00638 
00639         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"\nSExec::ssh_copy_to($localpath, $remotepath)\n"</span>;
00640 
00641 <span class="comment">/*      This would be great if SCP could hijack the shared connection (sic)</span>
00642 <span class="comment">        umask(0077);</span>
00643 <span class="comment">        $tmpfname = tempnam($this-&gt;workdir, "copy-to-");</span>
00644 <span class="comment">        chmod($tmpfname, 0700);</span>
00645 <span class="comment">        putenv("DISPLAY=none:0.");</span>
00646 <span class="comment">        putenv("SSH_ASKPASS=$tmpfname");</span>
00647 <span class="comment">        $fp = fopen($tmpfname, "w");</span>
00648 <span class="comment">        fputs($fp, "#!/bin/sh\necho $this-&gt;password\n");</span>
00649 <span class="comment">        if (! $debug_sexec)  </span>
00650 <span class="comment">            fputs($fp, "/bin/touch $tmpfname.called\n");</span>
00651 <span class="comment">        else</span>
00652 <span class="comment">            fputs($fp, "/bin/rm $tmpfname\n");</span>
00653 <span class="comment">        fclose($fp);</span>
00654 <span class="comment">        if ($debug_sexec) echo "$this-&gt;scp -pqrC $localpath $this-&gt;remote:$remotepath\n";</span>
00655 <span class="comment">        $out = "";</span>
00656 <span class="comment">        exec("$this-&gt;scp -pqrC $localpath $this-&gt;remote:$remotepath", $out, $status);</span>
00657 <span class="comment">        if ($status == 0)</span>
00658 <span class="comment">            return TRUE;</span>
00659 <span class="comment">        else {</span>
00660 <span class="comment">            if ($debug_sexec) echo $out . "\n";</span>
00661 <span class="comment">            return FALSE;</span>
00662 <span class="comment">        }</span>
00663 <span class="comment">*/</span>
00664         <span class="comment">// NOTE THAT WE NEED GNU TAR !!!</span>
00665         $retval = $this-&gt;ssh_exec(<span class="stringliteral">"test -d $remotepath 2&gt;&amp;1"</span>, $out);
00666         <span class="keywordflow">if</span> ($retval == 0) {
00667             <span class="comment">// destination is a directory, copy $local inside it</span>
00668             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt; Remote is a directory\n"</span>;
00669             $fn = basename($localpath);
00670             $dn = dirname($localpath);
00671             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt; Executing\n"</span> .
00672                 <span class="stringliteral">"/bin/tar -C $dn -cf - $fn | "</span> .
00673                 <span class="stringliteral">"ssh -x -T -C -S  $this-&gt;mplex_socket $this-&gt;remote "</span> .
00674                 <span class="stringliteral">"\"/bin/tar -C $remotepath -xf -\"\n"</span>;
00675             exec(<span class="stringliteral">"(/bin/tar -C $dn -cf - $fn | "</span> .
00676                  <span class="stringliteral">"ssh -x -T -C -S  $this-&gt;mplex_socket $this-&gt;remote "</span> .
00677                  <span class="stringliteral">"\"/bin/tar -C $remotepath -xf -\")2&gt;&amp;1"</span>, 
00678                 $out, $retval);
00679         } <span class="keywordflow">else</span> {
00680             <span class="comment">// destination is not a directory, copy _to_ it</span>
00681             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) 
00682                 echo <span class="stringliteral">"--&gt; remote is not a directory or does not exist\n"</span>;
00683             <span class="keywordflow">if</span> ((file_exists(<span class="stringliteral">"$localpath/."</span>)) &amp;&amp; (is_dir(<span class="stringliteral">"$localpath/."</span>))) {
00684                 <span class="comment">// if local is a dir, try to create it remotely with new name</span>
00685                 $retval = $this-&gt;ssh_exec(<span class="stringliteral">"/bin/mkdir -p $remotepath "</span>, $out);
00686                 <span class="keywordflow">if</span> ($retval != 0) {
00687                     <span class="comment">// we can't create it, either it already exists as a</span>
00688                     <span class="comment">// regular file or we don't have permissions, anyhow,</span>
00689                     <span class="comment">// we can't do the copy</span>
00690                     <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) print_r($out);
00691                     <span class="keywordflow">return</span> FALSE;
00692                 }
00693                 <span class="comment">// now cd lo local and copy over to remote</span>
00694                 <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt; Executing \n"</span> .
00695                         <span class="stringliteral">"    /bin/tar -C $localpath -cf - . | \n"</span> .
00696                         <span class="stringliteral">"    $this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote \n"</span> .
00697                         <span class="stringliteral">"    /bin/tar -C $remotepath -xf -\n"</span>;
00698                 exec(<span class="stringliteral">"(/bin/tar -C $localpath -cf - . | "</span> .
00699                     <span class="stringliteral">"$this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote "</span> .
00700                     <span class="stringliteral">"/bin/tar -C $remotepath -xf -)2&gt;&amp;1"</span>, 
00701                     $out, $retval);
00702             }
00703             <span class="keywordflow">else</span> {
00704                 <span class="comment">// non-dir: file, block-special, char-special, pipe, socket...</span>
00705                 <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt; Executing \n"</span> .
00706                     <span class="stringliteral">"    cat $localpath | \n"</span> .
00707                     <span class="stringliteral">"    $this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote \n"</span> .
00708                     <span class="stringliteral">"    \"cat &gt; $remotepath\"\n"</span>;
00709                 exec(<span class="stringliteral">"(cat $localpath | "</span> .
00710                     <span class="stringliteral">"$this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote "</span> .
00711                     <span class="stringliteral">"\"cat &gt; $remotepath\") 2&gt;&amp;1"</span>, $out, $retval);
00712             }
00713         }
00714         <span class="keywordflow">if</span> ($retval != 0) {
00715             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) print_r($out);
00716             <span class="keywordflow">return</span> FALSE;
00717         }
00718         <span class="keywordflow">else</span>
00719             <span class="keywordflow">return</span> TRUE;
00720     }
00721     <span class="comment"></span>
00722 <span class="comment">    /**</span>
00723 <span class="comment">     *  Copy a file or directory from a remote source to a local destination</span>
00724 <span class="comment">     *</span>
00725 <span class="comment">     *  This function copies source to dest, where first of them is a</span>
00726 <span class="comment">     * remote filespec and then comes a local filespec, both specified </span>
00727 <span class="comment">     * as normal system paths.</span>
00728 <span class="comment">     *</span>
00729 <span class="comment">     *  Both, local and remote paths may be absolute or relative.</span>
00730 <span class="comment">     *</span>
00731 <span class="comment">     *  If the original source is a directory, it will be copied</span>
00732 <span class="comment">     * recursively to destination (hence easing file transfers).</span>
00733 <span class="comment">     *</span>
00734 <span class="comment">     *  The function returns TRUE on success or FALSE on failure.</span>
00735 <span class="comment">     *</span>
00736 <span class="comment">     *  @param string   The origin remote path, either absolute or</span>
00737 <span class="comment">     *                  relative to the login home. If it denotes a </span>
00738 <span class="comment">     *                  directory, the copy will be recursive.</span>
00739 <span class="comment">     *</span>
00740 <span class="comment">     *  @param string    The local destination path, either</span>
00741 <span class="comment">     *                  absolute or relative to the current working</span>
00742 <span class="comment">     *                  directory.</span>
00743 <span class="comment">     *</span>
00744 <span class="comment">     *  @param array   An optional array of strings to be appended the </span>
00745 <span class="comment">     *                  copy operation's output for debugging/diagnostics.</span>
00746 <span class="comment">     *</span>
00747 <span class="comment">     *  @return bool TRUE if all went well, or FALSE on failure.</span>
00748 <span class="comment">     *</span>
00749 <span class="comment">     *  @access public</span>
00750 <span class="comment">     *  @since Method available since Release 1.0</span>
00751 <span class="comment">     */</span>
00752     function ssh_copy_from($remotepath, $localpath, &amp;$out)
00753     {
00754         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
00755 
00756         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"SExec::ssh_copy_from($remotepath, $localpath)\n"</span>;
00757 
00758 <span class="comment">/*      This would be great if SCP could hijack the shared connection (sic)</span>
00759 <span class="comment">        umask(0077);</span>
00760 <span class="comment">        $tmpfname = tempnam($this-&gt;workdir, "copy-from-");</span>
00761 <span class="comment">        chmod($tmpfname, 0700);</span>
00762 <span class="comment">        putenv("DISPLAY=none:0.");</span>
00763 <span class="comment">        putenv("SSH_ASKPASS=$tmpfname");</span>
00764 <span class="comment">        $fp = fopen($tmpfname, "w");</span>
00765 <span class="comment">        fputs($fp, "#!/bin/sh\necho $this-&gt;password\n");</span>
00766 <span class="comment">        if (! $debug_sexec)  </span>
00767 <span class="comment">            fputs($fp, "/bin/touch $tmpfname.called\n");</span>
00768 <span class="comment">        else</span>
00769 <span class="comment">            fputs($fp, "/bin/rm $tmpfname\n");</span>
00770 <span class="comment">        fclose($fp);</span>
00771 <span class="comment">        if ($debug_sexec) echo "$this-&gt;scp -pqrC $this-&gt;remote:$remotepath $localpath\n";</span>
00772 <span class="comment">        $out = "";</span>
00773 <span class="comment">        exec("$this-&gt;scp -pqrC $this-&gt;remote:$remotepath $localpath", $out, $status);</span>
00774 <span class="comment">        if ($status == 0)</span>
00775 <span class="comment">            return TRUE;</span>
00776 <span class="comment">        else {</span>
00777 <span class="comment">            if ($debug_sexec) echo $out . "\n";</span>
00778 <span class="comment">            return FALSE;</span>
00779 <span class="comment">        }</span>
00780 <span class="comment">*/</span>      
00781         <span class="keywordflow">if</span> ((file_exists(<span class="stringliteral">"$localpath/."</span>)) &amp;&amp; (is_dir(<span class="stringliteral">"$localpath/."</span>))) {
00782             <span class="comment">// Local is a directory. Copy remote into it.</span>
00783             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt; $localpath/. is a dir\n"</span>;
00784             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt; Executing\n"</span> .
00785             <span class="stringliteral">"$this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote "</span> .
00786                     <span class="stringliteral">"\"/bin/tar -C "</span> .dirname($remotepath). 
00787                         <span class="stringliteral">" -cf - "</span>. basename($remotepath) .<span class="stringliteral">"\" | "</span>.
00788                         <span class="stringliteral">"/bin/tar -C $localpath -xf -\n"</span>;
00789             exec(<span class="stringliteral">"($this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote "</span> .
00790                     <span class="stringliteral">"\"/usr/local/bin/tar -C "</span> .dirname($remotepath). 
00791                         <span class="stringliteral">" -cf - "</span>. basename($remotepath) .<span class="stringliteral">"\" | "</span>.
00792                         <span class="stringliteral">"/bin/tar -C $localpath -xf -) 2&gt;&amp;1"</span>,
00793                  $out, $res);
00794         }
00795         <span class="keywordflow">else</span> {
00796             <span class="comment">// either the local side does not exist or is not a directory</span>
00797             <span class="comment">// if remote is a directory</span>
00798             <span class="comment">//      make local equivalent and copy contents (make will</span>
00799             <span class="comment">//      fail if local exists as a non-dir)</span>
00800             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt; $localpath is NOT a dir\n"</span>;
00801             $res = $this-&gt;ssh_exec(<span class="stringliteral">"test -d $remotepath 2&gt;&amp;1"</span>, $out);
00802             <span class="keywordflow">if</span> ($res == 0) {
00803                 exec(<span class="stringliteral">"/bin/mkdir -p $localpath 2&gt;&amp;1"</span>, $out, $res);
00804                 <span class="keywordflow">if</span> ($res != 0) {
00805                     <span class="comment">// can't create the dir, either it is a regular file</span>
00806                     <span class="comment">// or we don't have privileges</span>
00807                     <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) print_r($out);
00808                     <span class="keywordflow">return</span> FALSE;
00809                 }
00810                 <span class="comment">// copy in the remote contents</span>
00811                 <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt;Executing\n"</span> .
00812                     <span class="stringliteral">"($this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote "</span> .
00813                     <span class="stringliteral">"\"/bin/tar -C $remotepath -cf - .\" | "</span> .
00814                     <span class="stringliteral">"/bin/tar -C $localpath -xf -)2&gt;&amp;1\n"</span>;
00815                 exec(<span class="stringliteral">"($this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote "</span> .
00816                     <span class="stringliteral">"\"/bin/tar -C $remotepath -cf - .\" | "</span> .
00817                     <span class="stringliteral">"/bin/tar -C $localpath -xf -)2&gt;&amp;1"</span>,
00818                     $out, $res);
00819                 
00820             } <span class="keywordflow">else</span> {
00821                 <span class="comment">// remote is a non-dir: cat over local</span>
00822                 <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"--&gt;Executing\n"</span> .
00823                     <span class="stringliteral">"($this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote "</span> .
00824                     <span class="stringliteral">"\"cat $remotepath\" | "</span>.
00825                     <span class="stringliteral">" cat &gt; $localpath) 2&gt;&amp;1\n"</span>;
00826                 exec(<span class="stringliteral">"($this-&gt;ssh -x -T -C -S $this-&gt;mplex_socket $this-&gt;remote "</span> .
00827                     <span class="stringliteral">"\"cat $remotepath\" | "</span>.
00828                     <span class="stringliteral">" cat &gt; $localpath) 2&gt;&amp;1"</span>, $out, $res);
00829             }
00830         }
00831         <span class="keywordflow">if</span> ($res == 0) 
00832             <span class="keywordflow">return</span> TRUE;
00833         <span class="keywordflow">else</span> {
00834             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) print_r($out);
00835             <span class="keywordflow">return</span> FALSE;
00836         }
00837     }
00838 <span class="comment"></span>
00839 <span class="comment">    /**</span>
00840 <span class="comment">     *  Execute a single command remotely</span>
00841 <span class="comment">     *</span>
00842 <span class="comment">     *  Execute a single command remotely using ssh and </span>
00843 <span class="comment">     * display its output, optionally returning its exit </span>
00844 <span class="comment">     * status (like passthru)</span>
00845 <span class="comment">     *</span>
00846 <span class="comment">     *  This function is intended to be used as a one-time</span>
00847 <span class="comment">     * all-at-once non-interactive execution mechanism which</span>
00848 <span class="comment">     * will run the command remotely and display its output.</span>
00849 <span class="comment">     *</span>
00850 <span class="comment">     *  If you try to issue an interactive command using this</span>
00851 <span class="comment">     * function, all you will get is unneccessary trouble. So</span>
00852 <span class="comment">     * don't!</span>
00853 <span class="comment">     *</span>
00854 <span class="comment">     *  This might be done as well using a pipe on /tmp and</span>
00855 <span class="comment">     * making the command 'cat' the pipe: when ssh runs, it</span>
00856 <span class="comment">     * runs the command 'cat' on the pipe and hangs on read.</span>
00857 <span class="comment">     *  Then we just need a thread to open the pipe, put the</span>
00858 <span class="comment">     * password and close the pipe.</span>
00859 <span class="comment">     *</span>
00860 <span class="comment">     *  This other way the password is never wirtten down.</span>
00861 <span class="comment">     * But, OTOH, the file life is so ephemeral that most</span>
00862 <span class="comment">     * of the time it will only exist in the internal system</span>
00863 <span class="comment">     * cache, so this approach is not that bad either.</span>
00864 <span class="comment">     *</span>
00865 <span class="comment">     *  @see passthru()</span>
00866 <span class="comment">     *</span>
00867 <span class="comment">     *  @param string command  The command to execute on the remote end</span>
00868 <span class="comment">     *                      NOTE: if you want to use redirection, the</span>
00869 <span class="comment">     *                      entire remote command line should be </span>
00870 <span class="comment">     *                      enclosed in additional quotes!</span>
00871 <span class="comment">     *  @param integer status   Optional, this will hold the termination</span>
00872 <span class="comment">     *                      status of SSH after invocation, which</span>
00873 <span class="comment">     *                      should be the exit status of the remote</span>
00874 <span class="comment">     *                      command or 255 if an error occurred</span>
00875 <span class="comment">     *  @return void</span>
00876 <span class="comment">     *</span>
00877 <span class="comment">     *  @access public</span>
00878 <span class="comment">     *  @since Method available since Release 1.0</span>
00879 <span class="comment">     */</span>
00880     function <a class="code" href="test_2util_8php.html#a5">ssh_passthru</a>($command, &amp;$status)
00881     {
00882         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
00883 
00884         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"status = $status\n"</span>;
00885         <span class="comment">// go</span>
00886         <span class="keywordflow">if</span> (isset($status)) {
00887             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"st: $this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\"\n"</span>;
00888             passthru(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>, $status);
00889         }
00890         <span class="keywordflow">else</span> {
00891             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"~st: $this-&gt;ssh -x -t -t  -S $this-&gt;mplex_socket $this-&gt;remote \"$command\"\n"</span>;
00892             passthru(<span class="stringliteral">"$this-&gt;ssh -x -t -t  -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>);
00893         }
00894     }
00895     
00896     <span class="comment"></span>
00897 <span class="comment">    /**</span>
00898 <span class="comment">     *  Execute a remote command using SSH</span>
00899 <span class="comment">     *</span>
00900 <span class="comment">     *  This function sort of mimics rexec(3) using SSH as the transport</span>
00901 <span class="comment">     * protocol.</span>
00902 <span class="comment">     *</span>
00903 <span class="comment">     *  The function returns the exit status of the remote command, and</span>
00904 <span class="comment">     * appends the remote job output to an optional argument.</span>
00905 <span class="comment">     *</span>
00906 <span class="comment">     *  This function is intended to be used as a one-time</span>
00907 <span class="comment">     * all-at-once non-interactive execution mechanism which</span>
00908 <span class="comment">     * will run the command remotely and return its output.</span>
00909 <span class="comment">     *</span>
00910 <span class="comment">     *  If you try to issue an interactive command using this</span>
00911 <span class="comment">     * function, all you will get is unneccessary trouble. So</span>
00912 <span class="comment">     * don't!</span>
00913 <span class="comment">     *</span>
00914 <span class="comment">     *  @param string command  The command to execute on the remote end</span>
00915 <span class="comment">     *                      NOTE: if you want to use redirection, the</span>
00916 <span class="comment">     *                      entire remote command line should be </span>
00917 <span class="comment">     *                      enclosed in additional quotes!</span>
00918 <span class="comment">     *  @param  array If the output argument is present, then the specified </span>
00919 <span class="comment">     *                      array will be filled with every line of output </span>
00920 <span class="comment">     *                      from the command. Line endings, such as \n, are </span>
00921 <span class="comment">     *                      not included in this array. Note that if the array </span>
00922 <span class="comment">     *                      already contains some elements, exec() will append </span>
00923 <span class="comment">     *                      to the end of the array. If you do not want the </span>
00924 <span class="comment">     *                      function to append elements, call unset() on the </span>
00925 <span class="comment">     *                      array before passing it to exec().</span>
00926 <span class="comment">     *  @return integer status  will hold the termination</span>
00927 <span class="comment">     *                      status of SSH after invocation, which</span>
00928 <span class="comment">     *                      should be the exit status of the remote</span>
00929 <span class="comment">     *                      command or 255 if an error occurred</span>
00930 <span class="comment">     *</span>
00931 <span class="comment">     *  @access public</span>
00932 <span class="comment">     *  @since Method available since Release 1.0</span>
00933 <span class="comment">     */</span>
00934     function ssh_exec($command, &amp;$out)
00935     {
00936         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
00937 
00938         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"SExec::ssh_exec($command, $out)\n"</span>;
00939         umask(0077);
00940         $tmpfname = tempnam($this-&gt;workdir, 'exec');
00941         chmod($tmpfname, 0700);
00942         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo $tmpfname . <span class="stringliteral">"\n"</span>;
00943 
00944         exec(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>, $out, $retval);
00945         <span class="keywordflow">return</span> $retval;
00946 
00947     }
00948     <span class="comment"></span>
00949 <span class="comment">    /**</span>
00950 <span class="comment">     *  Open an SSH connection to a remote site with a shell to run </span>
00951 <span class="comment">     * interactive commands</span>
00952 <span class="comment">     *</span>
00953 <span class="comment">     *  Connects to a remote host and opens an interactive shell session</span>
00954 <span class="comment">     * with NO controlling terminal.</span>
00955 <span class="comment">     *</span>
00956 <span class="comment">     *  This routine creates communication streams with the remote shell,</span>
00957 <span class="comment">     * and stores all output (standard and error) of the connection into</span>
00958 <span class="comment">     * two separate local log files (one for stdout and one for stderr).</span>
00959 <span class="comment">     *</span>
00960 <span class="comment">     *  Returns a process_control array which contains the process resource</span>
00961 <span class="comment">     * ID and an the standard file descriptors which the caller may use to</span>
00962 <span class="comment">     * interact with the remote shell.</span>
00963 <span class="comment">     *</span>
00964 <span class="comment">     * The process control array contains:</span>
00965 <span class="comment">     *</span>
00966 <span class="comment">     *  'process' -- the process resource for the newly created connection</span>
00967 <span class="comment">     *</span>
00968 <span class="comment">     *  'std_in' -- handle to the standard input of the new connection</span>
00969 <span class="comment">     *</span>
00970 <span class="comment">     *  'std_out' -- handle to standard output of the new connection</span>
00971 <span class="comment">     *</span>
00972 <span class="comment">     *  'std_err' -- handle to standard error of the new connection</span>
00973 <span class="comment">     *</span>
00974 <span class="comment">     *  'stdout_file' -- actual filename of the local log file for the</span>
00975 <span class="comment">     *          new connection standard output</span>
00976 <span class="comment">     *</span>
00977 <span class="comment">     *  'stderr_file' -- actual filename of the local log file for the</span>
00978 <span class="comment">     *          new connection standard error</span>
00979 <span class="comment">     *</span>
00980 <span class="comment">     *  @return mixed|false a process control associative array or FALSE</span>
00981 <span class="comment">     *          on failure.</span>
00982 <span class="comment">     *</span>
00983 <span class="comment">     *  @access public</span>
00984 <span class="comment">     *  @since Method available since Release 1.0</span>
00985 <span class="comment">     */</span>
00986     function ssh_open_shell()
00987     {   
00988         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
00989 
00990         <span class="comment">// Open a child process with the 'proc_open' function. </span>
00991         <span class="comment">//</span>
00992         <span class="comment">// Some tricks: we must open the connection using '-x' to disable</span>
00993         <span class="comment">// X11 forwarding, and use '-t -t' to avoid SSH generating an error</span>
00994         <span class="comment">// because we are not connected to any terminal.</span>
00995         <span class="comment">//</span>
00996         <span class="comment">// NOTE: if the web server is trusted remotely (i.e. it's SSH public </span>
00997         <span class="comment">// key is accepted in ~user@host:.ssh/authorized_keys) then any </span>
00998         <span class="comment">// password will do.</span>
00999 
01000         <span class="comment">// Prepare I/O</span>
01001         umask(0077);
01002         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) {
01003             $child_stdout = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-"</span>.getmypid().<span class="stringliteral">"-O-"</span>);
01004             $child_stderr = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-"</span>.getmypid().<span class="stringliteral">"-E-"</span>);
01005         } <span class="keywordflow">else</span> {
01006             $child_stdout = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-"</span>);
01007             $child_stderr = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-"</span>);
01008         }
01009         $descriptorspec = array(
01010             0 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"r"</span>),  <span class="comment">// connect child's stdin to the read end of a pipe</span>
01011             1 =&gt; array(<span class="stringliteral">"file"</span>, $child_stdout, <span class="stringliteral">"a"</span>),  <span class="comment">// connect child's stdout to the write end of a pipe</span>
01012             2 =&gt; array(<span class="stringliteral">"file"</span>, $child_stderr, <span class="stringliteral">"a"</span>)   <span class="comment">// stderr is a pipe to read from</span>
01013         );
01014         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote&lt;br /&gt;\n"</span>;
01015         $process = proc_open(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote"</span>, 
01016                          $descriptorspec,
01017                          $pipes);
01018         
01019         <span class="comment">// check status</span>
01020         <span class="keywordflow">if</span> ((!is_resource($process)) || ($process == FALSE)) 
01021         {
01022             <a class="code" href="test_2util_8php.html#a4">letal</a>(<span class="stringliteral">"SSH::connect"</span>, <span class="stringliteral">"cannot connect to the remote host"</span>);
01023             <span class="keywordflow">return</span> FALSE;
01024         }
01025         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"proc_open done&lt;br /&gt;\n"</span>;
01026 
01027         <span class="comment">// $pipes now looks like this:</span>
01028         <span class="comment">//   0 =&gt; writeable handle connected to child stdin</span>
01029         
01030         <span class="comment">// Open child's stdin and stdout</span>
01031         $pipes[1] = fopen($child_stdout, <span class="stringliteral">"r"</span>);
01032         $pipes[2] = fopen($child_stderr, <span class="stringliteral">"r"</span>);
01033         
01034         <span class="comment">// Should we leave this to the user?</span>
01035         <span class="comment">// set to non-blocking and avoid having to call fflush</span>
01036         <span class="comment">//stream_set_blocking($pipes[0], FALSE);</span>
01037         <span class="comment">//stream_set_blocking($pipes[1], FALSE);</span>
01038         <span class="comment">//stream_set_blocking($pipes[2], FALSE);</span>
01039         stream_set_write_buffer($pipes[0], 0);
01040         stream_set_write_buffer($pipes[1], 0);
01041         stream_set_write_buffer($pipes[2], 0);
01042 
01043         <span class="comment">// We now have a connection to the remote SSH</span>
01044         <span class="comment">// Server which we may use to send commands/receive output</span>
01045         $p = array('process' =&gt; $process
01046                     ,'std_in' =&gt; $pipes[0]
01047                     ,'std_out' =&gt; $pipes[1]
01048                     ,'std_err' =&gt; $pipes[2] 
01049                     ,'stdout_file' =&gt; $child_stdout
01050                     ,'stderr_file' =&gt; $child_stderr
01051                    );
01052         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>)  {
01053             echo <span class="stringliteral">"process descriptor array is \n"</span>;
01054             print_r($p);
01055         }
01056         <span class="keywordflow">return</span> $p;
01057     }
01058     <span class="comment"></span>
01059 <span class="comment">    /**</span>
01060 <span class="comment">     *  Open an SSH connection to run an interactive command on a remote</span>
01061 <span class="comment">     * site</span>
01062 <span class="comment">     *</span>
01063 <span class="comment">     *  Connects to a remote host and runs an interactive command</span>
01064 <span class="comment">     * with NO controlling terminal.</span>
01065 <span class="comment">     *</span>
01066 <span class="comment">     *  This routine creates communication streams with the remote shell,</span>
01067 <span class="comment">     * and stores all output (standard and error) of the connection into</span>
01068 <span class="comment">     * two separate local log files (one for stdout and one for stderr).</span>
01069 <span class="comment">     *</span>
01070 <span class="comment">     *  Returns a process_control array which contains the process resource</span>
01071 <span class="comment">     * ID and an the standard file descriptors which the caller may use to</span>
01072 <span class="comment">     * interact with the remote shell.</span>
01073 <span class="comment">     *</span>
01074 <span class="comment">     * The process control array contains:</span>
01075 <span class="comment">     *</span>
01076 <span class="comment">     *  'process' -- the process resource for the newly created connection</span>
01077 <span class="comment">     *</span>
01078 <span class="comment">     *  'std_in' -- handle to the standard input of the new connection</span>
01079 <span class="comment">     *</span>
01080 <span class="comment">     *  'std_out' -- handle to standard output of the new connection</span>
01081 <span class="comment">     *</span>
01082 <span class="comment">     *  'std_err' -- handle to standard error of the new connection</span>
01083 <span class="comment">     *</span>
01084 <span class="comment">     *  'stdout_file' -- actual filename of the local log file for the</span>
01085 <span class="comment">     *          new connection standard output</span>
01086 <span class="comment">     *</span>
01087 <span class="comment">     *  'stderr_file' -- actual filename of the local log file for the</span>
01088 <span class="comment">     *          new connection standard error</span>
01089 <span class="comment">     *</span>
01090 <span class="comment">     *  @param  string command to be executed interactively on the remote end</span>
01091 <span class="comment">     *</span>
01092 <span class="comment">     *  @return mixed|false a process control associative array or FALSE</span>
01093 <span class="comment">     *          on failure.</span>
01094 <span class="comment">     *</span>
01095 <span class="comment">     *  @access public</span>
01096 <span class="comment">     *  @since Method available since Release 1.0</span>
01097 <span class="comment">     */</span>
01098     function ssh_open_command($command)
01099     {   
01100         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
01101 
01102         <span class="comment">// Open a child process with the 'proc_open' function. </span>
01103         <span class="comment">//</span>
01104         <span class="comment">// Some tricks: we must open the connection using '-x' to disable</span>
01105         <span class="comment">// X11 forwarding, and use '-t -t' to avoid SSH generating an error</span>
01106         <span class="comment">// because we are not connected to any terminal.</span>
01107         <span class="comment">//</span>
01108         <span class="comment">// NOTE: if the web server is trusted remotely (i.e. it's SSH public </span>
01109         <span class="comment">// key is accepted in ~user@host:.ssh/authorized_keys) then any </span>
01110         <span class="comment">// password will do.</span>
01111 
01112         <span class="comment">// Prepare I/O</span>
01113         umask(0077);
01114         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) {
01115             $child_stdout = tempnam($this-&gt;workdir, <span class="stringliteral">"open_cmd-"</span>.getmypid().<span class="stringliteral">"-1-"</span>);
01116             $child_stderr = tempnam($this-&gt;workdir, <span class="stringliteral">"open_cmd-"</span>.getmypid().<span class="stringliteral">"-2-"</span>);
01117         } <span class="keywordflow">else</span> {
01118             $child_stdout = tempnam($this-&gt;workdir, <span class="stringliteral">"open_cmd-"</span>);
01119             $child_stderr = tempnam($this-&gt;workdir, <span class="stringliteral">"open_cmd-"</span>);
01120         }
01121         $descriptorspec = array(
01122             0 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"r"</span>),  <span class="comment">// connect child's stdin to the read end of a pipe</span>
01123             #1 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"a"</span>),  <span class="comment">// connect child's stdout to the write end of a pipe</span>
01124             #2 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"a"</span>)   <span class="comment">// stderr is a pipe to read from</span>
01125             1 =&gt; array(<span class="stringliteral">"file"</span>, $child_stdout, <span class="stringliteral">"a"</span>),
01126             2 =&gt; array(<span class="stringliteral">"file"</span>, $child_stderr, <span class="stringliteral">"a"</span>)
01127         );
01128 
01129         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote $command&lt;br /&gt;\n"</span>;
01130         $process = proc_open(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>, 
01131                          $descriptorspec,
01132                          $pipes);
01133         
01134         <span class="comment">// check status</span>
01135         <span class="keywordflow">if</span> ((!is_resource($process)) || ($process == FALSE)) 
01136         {
01137             <a class="code" href="test_2util_8php.html#a4">letal</a>(<span class="stringliteral">"SSH::connect"</span>, <span class="stringliteral">"cannot connect to the remote host"</span>);
01138             <span class="keywordflow">return</span> FALSE;
01139         }
01140         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"proc_open done&lt;br /&gt;\n"</span>;
01141 
01142         <span class="comment">// $pipes now looks like this:</span>
01143         <span class="comment">//   0 =&gt; writeable handle connected to child stdin</span>
01144         
01145         <span class="comment">// Open child's stdin and stdout</span>
01146         $pipes[1] = fopen($child_stdout, <span class="stringliteral">"r"</span>);
01147         $pipes[2] = fopen($child_stderr, <span class="stringliteral">"r"</span>);
01148         
01149         <span class="comment">// Should we leave this to the user?</span>
01150         <span class="comment">// set to non-blocking and avoid having to call fflush</span>
01151 <span class="preprocessor">        #stream_set_blocking($pipes[0], FALSE);</span>
01152 <span class="preprocessor"></span><span class="preprocessor">        #stream_set_blocking($pipes[1], FALSE);</span>
01153 <span class="preprocessor"></span><span class="preprocessor">        #stream_set_blocking($pipes[2], FALSE);</span>
01154 <span class="preprocessor"></span>        stream_set_write_buffer($pipes[0], 0);
01155         stream_set_write_buffer($pipes[1], 0);
01156         stream_set_write_buffer($pipes[2], 0);
01157 
01158         <span class="comment">// We now have a connection to the remote SSH</span>
01159         <span class="comment">// Server which we may use to send commands/receive output</span>
01160         $p = array('process' =&gt; $process
01161                     ,'std_in' =&gt; $pipes[0]
01162                     ,'std_out' =&gt; $pipes[1]
01163                     ,'std_err' =&gt; $pipes[2] 
01164                     ,'stdout_file' =&gt; $child_stdout
01165                     ,'stderr_file' =&gt; $child_stderr
01166                    );
01167         <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>)  {
01168             echo <span class="stringliteral">"process descriptor array is \n"</span>;
01169             print_r($p);
01170         }
01171         <span class="keywordflow">return</span> $p;
01172     }
01173     <span class="comment"></span>
01174 <span class="comment">    /**</span>
01175 <span class="comment">     * Get output until we reach a given regular expression</span>
01176 <span class="comment">     *</span>
01177 <span class="comment">     *  @note EXPERIMENTAL, requires more thought and experience.</span>
01178 <span class="comment">     */</span>
01179     function ssh_out_expect($p, $expr=<span class="stringliteral">"^# "</span>)
01180     {
01181         <span class="keywordflow">do</span> {
01182                 flush();
01183                 fseek($p[<span class="stringliteral">"std_out"</span>], $last);
01184                 $line = fgets($p[<span class="stringliteral">"std_out"</span>], 1024);
01185 <span class="preprocessor">                 #echo "&gt;&gt; ".$line;</span>
01186 <span class="preprocessor"></span>                $last = ftell($p[<span class="stringliteral">"std_out"</span>]);
01187         } <span class="keywordflow">while</span> ((! feof($p[<span class="stringliteral">"std_out"</span>]) ) || (! ereg($expr, $line)));
01188     }
01189 <span class="comment"></span>
01190 <span class="comment">    /**</span>
01191 <span class="comment">     * Close an SSH interactive session</span>
01192 <span class="comment">     *</span>
01193 <span class="comment">     *  This method terminates a previously open interactive remote </span>
01194 <span class="comment">     * session. It will send a termination notification to the</span>
01195 <span class="comment">     * remote end, close the connection with control and communication</span>
01196 <span class="comment">     * streams, and terminate the local control process.</span>
01197 <span class="comment">     *</span>
01198 <span class="comment">     *  Copies of the log files that contain the output and error</span>
01199 <span class="comment">     * of the communication are left out for later reference and </span>
01200 <span class="comment">     * local peruse. If you don't need them any longer, you may</span>
01201 <span class="comment">     * delete them or just leave them around until the class destructor</span>
01202 <span class="comment">     * is called (which will remove all session traces),</span>
01203 <span class="comment">     *</span>
01204 <span class="comment">     *  @param mixed p an associative array with the description of the interactive</span>
01205 <span class="comment">     *          session control process, obtained by a previous call to one</span>
01206 <span class="comment">     *          of the interactive session creation methods ssh_open_shell()</span>
01207 <span class="comment">     *          or ssh_open_command().</span>
01208 <span class="comment">     *</span>
01209 <span class="comment">     *  @return integer the exit status of the remote interactive session.</span>
01210 <span class="comment">     *</span>
01211 <span class="comment">     *  @access public</span>
01212 <span class="comment">     *  @since Method available since Release 1.0</span>
01213 <span class="comment">     */</span>
01214     function ssh_close($p)
01215     {
01216         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
01217         
01218             fwrite($p['std_in'], <span class="stringliteral">"\n"</span>);
01219             fwrite($p['std_in'], <span class="stringliteral">"logout\n"</span>);
01220             fflush($p['std_in']);
01221             fclose($p['std_in']); fclose($p['std_out']); fclose($p['std_err']);
01222             <span class="keywordflow">if</span> (<a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>) echo <span class="stringliteral">"pipes/files closed\n"</span>;
01223             <span class="comment">// XXX we should delete the log files here...</span>
01224             <span class="keywordflow">return</span> proc_close($p['process']);
01225     }
01226     
01227 <span class="preprocessor">#    if ($php_version &gt;= 5)</span>
01228 <span class="preprocessor"></span><span class="preprocessor">#    {</span>
01229 <span class="preprocessor"></span><span class="preprocessor">#       </span><span class="comment">/**</span>
01230 <span class="comment">#        * send a signal to a running ssh_open_* process</span>
01231 <span class="comment">#        */</span>
01232 <span class="preprocessor">#       function ssh_signal($p, $signal)</span>
01233 <span class="preprocessor"></span><span class="preprocessor">#       {</span>
01234 <span class="preprocessor"></span><span class="preprocessor">#           return proc_terminate($p['process'], $signal);</span>
01235 <span class="preprocessor"></span><span class="preprocessor">#       }</span>
01236 <span class="preprocessor"></span><span class="preprocessor">#       </span><span class="comment">/**</span>
01237 <span class="comment">#        * get info about a running ssh_open_* process</span>
01238 <span class="comment">#        */</span>
01239 <span class="preprocessor">#       function ssh_get_status($p)</span>
01240 <span class="preprocessor"></span><span class="preprocessor">#       {</span>
01241 <span class="preprocessor"></span><span class="preprocessor">#           return proc_get_status($p['process']);</span>
01242 <span class="preprocessor"></span><span class="preprocessor">#       }</span>
01243 <span class="preprocessor"></span><span class="preprocessor">#    }</span>
01244 <span class="preprocessor"></span>    <span class="comment"></span>
01245 <span class="comment">    /**</span>
01246 <span class="comment">     *  Execute a remote command and keep an unidirectional stream</span>
01247 <span class="comment">     * contact with it.</span>
01248 <span class="comment">     *</span>
01249 <span class="comment">     *  This routine mimics 'popen()' but uses ssh to connect to</span>
01250 <span class="comment">     * a remote host and run the requested command: in other words,</span>
01251 <span class="comment">     * it opens a pipe to a remotely executed command. This pipe is</span>
01252 <span class="comment">     * unidirectional, with the communications direction controlled</span>
01253 <span class="comment">     * by a method parameter.</span>
01254 <span class="comment">     *</span>
01255 <span class="comment">     *  @see popen() for more details.</span>
01256 <span class="comment">     *</span>
01257 <span class="comment">     *  @param string command is the command to execute on the remote end</span>
01258 <span class="comment">     *</span>
01259 <span class="comment">     *  @param string mode specifies the communications direction for the </span>
01260 <span class="comment">     *          pipe: if set to "r" (read), then we will be able to</span>
01261 <span class="comment">     *          collect command output only; if set to "w" (write)</span>
01262 <span class="comment">     *          then we may only send input to the remote command.</span>
01263 <span class="comment">     *</span>
01264 <span class="comment">     *  @return resource a handle to the unidirectional communication stream,</span>
01265 <span class="comment">     *          similar to that returned by fopen(), or FALSE on</span>
01266 <span class="comment">     *          failure. This handle must be closed with ssh_pclose().</span>
01267 <span class="comment">     *</span>
01268 <span class="comment">     *  @access public</span>
01269 <span class="comment">     *  @since Method available since Release 1.0</span>
01270 <span class="comment">     */</span>
01271     function ssh_popen($command, $mode)
01272     {
01273         global <a class="code" href="grid__test_8php.html#a1">$debug_sexec</a>;
01274 
01275         <span class="comment">// go</span>
01276         <span class="keywordflow">return</span> popen(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>, $mode);
01277     }
01278     <span class="comment"></span>
01279 <span class="comment">    /**</span>
01280 <span class="comment">     * Close a piped remote execution command control pipe.</span>
01281 <span class="comment">     *</span>
01282 <span class="comment">     *  This routine accepts as input the handle for the control stream</span>
01283 <span class="comment">     * of a remote command and closes it, terminating the command as well.</span>
01284 <span class="comment">     * The handle must be valid and obtained through a call to ssh_popen().</span>
01285 <span class="comment">     *</span>
01286 <span class="comment">     *  @param resource f is the file handle associated with the pipe control stream</span>
01287 <span class="comment">     *</span>
01288 <span class="comment">     *  @return integer the termination status of the command that was run.</span>
01289 <span class="comment">     *</span>
01290 <span class="comment">     *  @access public</span>
01291 <span class="comment">     *  @since Method available since Release 1.0</span>
01292 <span class="comment">     */</span>
01293     function ssh_pclose($f)
01294     {
01295         <span class="keywordflow">return</span> pclose($f);
01296     }
01297 
01298     <span class="comment">//}}}</span>
01299 }
01300 
01301 <span class="comment">/*</span>
01302 <span class="comment"> * Local variables:</span>
01303 <span class="comment"> * tab-width: 4</span>
01304 <span class="comment"> * c-basic-offset: 4</span>
01305 <span class="comment"> * c-hanging-comment-ender-p: nil</span>
01306 <span class="comment"> * End:</span>
01307 <span class="comment"> */</span>
01308 
01309 ?&gt;
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Thu Jun 22 10:01:10 2006 for php::Grid by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > </a>1.3.6 </small></address>
</body>
</html>
