<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>Docs for page grock_lib.php</title>
	<link rel="stylesheet" type="text/css" id="layout" href="../media/layout.css" media="screen">
	<link rel="stylesheet" type="text/css" href="../media/style.css" media="all">
	<link rel="stylesheet" type="text/css" href="../media/print.css" media="print">
</head>

<body>
<div id="header">
	<div id="navLinks">
		[ <a href="../classtrees_grock.html">Class Tree: grock</a> ]
		[ <a href="../elementindex_grock.html">Index: grock</a> ]
		[ <a href="../elementindex.html">All elements</a> ]
	</div>
	<div id="packagePosition">
		<div id="packageTitle2">grock</div>
		<div id="packageTitle">grock</div>
		<div id="elementPath"> &middot; </div>
	</div>
</div>

<div id="nav" class="small">
	<div id="packages">
		Packages:
					<p><a href="../li_GROCK.html">GROCK</a></p>
					<p><a href="../li_Grid.html">Grid</a></p>
					<p><a href="../li_grock.html">grock</a></p>
					<p><a href="../li_SExec.html">SExec</a></p>
			</div>

				<div id="index">
			<div id="files">
								Files:<br>
								<a href="../grock/_config_php.html">		config.php
		</a><br>
			<a href="../grock/_database_php.html">		database.php
		</a><br>
			<a href="../grock/_dock_php.html">		dock.php
		</a><br>
			<a href="../grock/_explore_complex_php.html">		explore_complex.php
		</a><br>
			<a href="../grock/_explore_match_php.html">		explore_match.php
		</a><br>
			<a href="../grock/_explore_molecule_php.html">		explore_molecule.php
		</a><br>
			<a href="../grock/_fishy_php.html">		fishy.php
		</a><br>
			<a href="../grock/_gramm_php.html">		gramm.php
		</a><br>
			<a href="../grock/_grid_config_php.html">		grid_config.php
		</a><br>
			<a href="../grock/_grock-ws_php.html">		grock-ws.php
		</a><br>
			<a href="../grock/_grock_php.html">		grock.php
		</a><br>
			<a href="../grock/_grock_lib_php.html">		grock_lib.php
		</a><br>
			<a href="../grock/_processor_php.html">		processor.php
		</a><br>
			<a href="../grock/_report_php.html">		report.php
		</a><br>
			<a href="../grock/_ssh_php.html">		ssh.php
		</a><br>
			<a href="../grock/_util_php.html">		util.php
		</a><br>
				</div>
			<div id="classes">
							</div>
		</div>
	</div>

<div id="body">
			<h1>Procedural File: grock_lib.php</h1>
	<p style="margin: 0px;">Source Location: /grock_lib.php</p>
	
<br>
<br>

<div class="contents">
<h2>Classes:</h2>
<dl>
</dl>
</div>

<h2>Page Details:</h2>
<p align="center"><strong>GROCK functions
</strong></p>
<p>Working routines used to carry on GROCK tasks. This module contains  functions used both by GROCK and by GROCK-output analyzer tools that  generate user reports.</p><p>This library is free software; you can redistribute it and/or  modify it under the terms of the GNU Lesser General Public  License as published by the Free Software Foundation; either  version 2.1 of the License, or (at your option) any later version.</p><p>This library is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; without even the implied warranty of  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  Lesser General Public License for more details.</p><p>You should have received a copy of the GNU Lesser General Public  License along with this library; if not, write to the Free Software  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</p><h4>Tags:</h4>
<ul>
	<li><b>see</b> - <a href="../grock/_database_php.html">database.php</a></li>
	<li><b>see</b> - <a href="../Grid/_grid_php.html">grid.php</a></li>
	<li><b>see</b> - <a href="../grock/_dock_php.html">dock.php</a></li>
	<li><b>link</b> - <a href="http://savannah.cern.ch/projects/GridGRAMM">http://savannah.cern.ch/projects/GridGRAMM</a></li>
	<li><b>since</b> - File available since release 0.0</li>
	<li><b>see</b> - <a href="../grock/_ssh_php.html">ssh.php</a></li>
	<li><b>see</b> - <a href="../grock/_util_php.html">util.php</a></li>
	<li><b>copyright</b> - CSIC</li>
	<li><b>author</b> - Jose R. Valverde &lt;<a href="mailto:david@cnb.uam.es">mailto:david@cnb.uam.es</a>&gt;</li>
	<li><b>license</b> - ../c/lgpl.txt</li>
	<li><b>version</b> - $Id$</li>
	<li><b>see</b> - <a href="../grock/_config_php.html">config.php</a></li>
	<li><b>author</b> - David Garcia &lt;<a href="mailto:david@cnb.uam.es">mailto:david@cnb.uam.es</a>&gt;</li>
</ul>
<hr>
Includes:<br>
require_once(<a href="../grock/_dock_php.html">"dock.php"</a>) <span class="linenumber">[line 45]</span>
<br />
require_once(<a href="../grock/_util_php.html">"util.php"</a>) <span class="linenumber">[line 41]</span>
<br />
require_once(<a href="../Grid/_grid_php.html">"grid.php"</a>) <span class="linenumber">[line 43]</span>
<br />
require_once(<a href="../grock/_config_php.html">"config.php"</a>) <span class="linenumber">[line 40]</span>
<br />
require_once(<a href="../grock/_ssh_php.html">"ssh.php"</a>) <span class="linenumber">[line 42]</span>
<br />
require_once(<a href="../grock/_database_php.html">"database.php"</a>) <span class="linenumber">[line 44]</span>
<br />
<hr>
<div id="global">
</div><hr>
<div id="define">
	<a name="defineMAX_TRIES"></a>
	<h3>MAX_TRIES</h3>
	<div class="indent">
	<p class="linenumber">[line 50]</p>
	<p><code>MAX_TRIES = 5</code></p>
	<p align="center"><strong>Maximum number of times a job should be retried before giving up
</strong></p>
		</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
</div><hr>
<div id="function">
	<a name="functionactivate_grid"></a>
	<h3>activate_grid</h3>
	<div class="indent">
		<code>void activate_grid(
string $session_id, string $auth)</code>
		<p class="linenumber">[line 230]</p>
		<p align="center"><strong>Activate the grid on the remote UI node.
</strong></p>
<p>Activate a grid session on the remote back end, using $session_id as  the working directory and location of log files.</p><p>This function will open a connection and create a proxy that is  valid for 48 hours. That should be enough for running our jobs.</p>		
		<h4>Parameters</h4>
		<ul>
					<li>
			<span class="type">string</span>
			<b>$session_id</b> 
			- 
			session_id</li>
					<li>
			<span class="type">string</span>
			<b>$auth</b> 
			- 
			The authentication token to connect to a remote back-end</li>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functiongrock_clean"></a>
	<h3>grock_clean</h3>
	<div class="indent">
		<code>void grock_clean(
)</code>
		<p class="linenumber">[line 752]</p>
		<p align="center"><strong>Clean up all data subdirectories leaving them as ghosts
</strong></p>
<p>This function removes all subdirectory contents, and leaves  the subdirectories themselves as ghosts. This should help in  debugging and reporting to figure out how far we went in the  processing without eating unneeded space any longer.</p><p>This clean up function will leave untouched all report and  log files so an external monitor may still see them.</p>		
		<h4>Parameters</h4>
		<ul>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functiongrock_get_output"></a>
	<h3>grock_get_output</h3>
	<div class="indent">
		<code>boolean grock_get_output(
string $session_id, array $auth)</code>
		<p class="linenumber">[line 551]</p>
		<p align="center"><strong>Get output for GROCK jobs
</strong></p>
<p>This function will loop over all jobs and check their status. If  they are finished, then it will check the output code:</p><p><ul><li>if not OK then resubmit the job once</li><li>if OK then get its output</li></ul>   XXX If timeout, jobs should be killed and resubmitted as well... Errr.   	How do we timeout? Maybe the JDL is the answer... But how long do   	we allow a job to run?</p><p>After it has finished the loop, if all output has been collected,  then it will return TRUE.</p><p>If some output could not be collected because either the jobs  were not completed, they terminated with error or the output is  not available, then return FALSE</p><p>NOTE: that is too simplistic and it might make sense to  indicate on return whether <ul><li>there are incomplete jobs</li><li>there are error-terminated jobs</li><li>there are terminated jobs with no output</li><li>everything went OK</li></ul>   This function must be called repeatedly and periodically as  otherwise we risk a job being completed but its results having  been lost/discarded for some reason.</p><h4>Tags:</h4>
<ul>
	<li><b>return</b> - TRUE if all output has been collected,                   FALSE otherwise</li>
</ul>
		
		<h4>Parameters</h4>
		<ul>
					<li>
			<span class="type">string</span>
			<b>$session_id</b> 
			- 
			the session whose jobs we will monitor</li>
					<li>
			<span class="type">array</span>
			<b>$auth</b> 
			- 
			the authentication information</li>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functiongrock_get_status"></a>
	<h3>grock_get_status</h3>
	<div class="indent">
		<code>string grock_get_status(
)</code>
		<p class="linenumber">[line 456]</p>
		<p align="center"><strong>Obtain status of GROCK process
</strong></p>
<p>As we need to provide access to a running GROCK jobs from  indpenendent instances of web pages invoked by the user at  his/her convenience, we need some way to access a presistent  instance of the progression status.</p><p>This routine allows us to access persistent storage hiding  implementation details.</p><h4>Tags:</h4>
<ul>
	<li><b>return</b> - status of running GROCK or FALSE if the status       could not be obtained (denotes a possible error condition).</li>
</ul>
		
		<h4>Parameters</h4>
		<ul>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functiongrock_letal"></a>
	<h3>grock_letal</h3>
	<div class="indent">
		<code>void grock_letal(
string $where, string $what)</code>
		<p class="linenumber">[line 778]</p>
		<p align="center"><strong>Output an error and die setting the program status to 'aborted'
</strong></p>
		
		<h4>Parameters</h4>
		<ul>
					<li>
			<span class="type">string</span>
			<b>$where</b> 
			- 
			A string identifying the location of the error</li>
					<li>
			<span class="type">string</span>
			<b>$what</b> 
			- 
			A description of the error condition detected</li>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functiongrock_mrproper"></a>
	<h3>grock_mrproper</h3>
	<div class="indent">
		<code>void grock_mrproper(
)</code>
		<p class="linenumber">[line 767]</p>
		<p align="center"><strong>Do a proper clean up of all data files
</strong></p>
<p>This function will delete the whole session directory including  log and error files, releasing all occupied space.</p><p>At some point in the future it might actually make a backup of  significant files to a cache directory for future reference of  additional searches with the same probe agains the same database.</p>		
		<h4>Parameters</h4>
		<ul>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functiongrock_set_probe_type"></a>
	<h3>grock_set_probe_type</h3>
	<div class="indent">
		<code>void grock_set_probe_type(
string $user_file)</code>
		<p class="linenumber">[line 196]</p>
		<p align="center"><strong>Ensure the user probe molecule has the appropriate name for further  processing by GROCK.
</strong></p>
<p>GROCK works internally using 'canonical' names for all its processing  (this makes the logic somewhat simpler, although it will probably be  removed at some future point).</p><p>This routine expects the user molecule to be located in the current  directory, named 'probe.pdb', and moves it to the actual name that  GROCK will need to process it.</p><p>The need to rename stems from the fact that the molecule will be  processed as a ligand (mobile) or receptor (static) molecule depending  on its size and the database selected. Hence we want to make sure it  is identified appropriately for the processing to be applied.</p><h4>Tags:</h4>
<ul>
	<li><b>access</b> - private</li>
</ul>
		
		<h4>Parameters</h4>
		<ul>
					<li>
			<span class="type">string</span>
			<b>$user_file</b> 
			- 
			the name to assign the newly uploaded data file.</li>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functiongrock_set_status"></a>
	<h3>grock_set_status</h3>
	<div class="indent">
		<code>boolean grock_set_status(
string $status)</code>
		<p class="linenumber">[line 427]</p>
		<p align="center"><strong>Set work progression status
</strong></p>
<p>Ours is a lengthy process, we do not want users to be tied  to a terminal waiting for this to finish. Since we are web  based, this is done by a separate web page, hence we need  some persistent way to monitor work progress.</p><p>This routine isolates the persistence implementation of  progression status.</p><h4>Tags:</h4>
<ul>
	<li><b>return</b> - TRUE if all goes OK,</li>
</ul>
		
		<h4>Parameters</h4>
		<ul>
					<li>
			<span class="type">string</span>
			<b>$status</b> 
			- 
			status to set</li>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functiongrock_submit"></a>
	<h3>grock_submit</h3>
	<div class="indent">
		<code>void grock_submit(
string $session_id, mixed $options, mixed $auth)</code>
		<p class="linenumber">[line 95]</p>
		<p align="center"><strong>Submit a high throughput docking search using a remote grid   back-end.
</strong></p>
<p>We expect to be called with a session name that identifies  a directory in the working area which already contains the  probe molecule file as 'probe.pdb'.</p><p>The parameters allow us to <ul><li>know the original name of the probe file</li><li>select the database to be searched</li><li>select the docking program to use and all its options</li><li>identify ourselves to the remote back-end</li></ul>   With this data in hand, we will be able to generate all  the separate jobs for performing the search with as much  parallelism as possible, and launch them to a remote  back end for processing.</p><p>In doing so, we will maintain a file with our status so  work may be monitored by an external process, a listing  file detailing all target molecules checked and a log file  in HTML format with a progress report (this last one may  be superfluous).</p><p>$options is an associative array containing   	'probe'   	'database'   	'docker' =&gt; 'gramm'   	    'resolution'   	    'representation'</p><p>$auth is an associative array containing   	'server'   	'user'   	'host'   	'password'   	'passphrase'</p>		
		<h4>Parameters</h4>
		<ul>
					<li>
			<span class="type">string</span>
			<b>$session_id</b> 
			- 
			Session identifier</li>
					<li>
			<span class="type">mixed</span>
			<b>$options</b> 
			- 
			An array containing the user options</li>
					<li>
			<span class="type">mixed</span>
			<b>$auth</b> 
			- 
			An array containing user authentication data</li>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functionjob_resubmit"></a>
	<h3>job_resubmit</h3>
	<div class="indent">
		<code>void job_resubmit(
<a href="../Grid/Grid.html">Grid</a> $eg, string $session_id, string $job)</code>
		<p class="linenumber">[line 684]</p>
		<p align="center"><strong>Resubmit a job to the grid up to a globally defined maximum number of times
</strong></p>
<p>We'll use an ancillary trace file in the job directory (named 'resubmitted')  to hold a count oof the number of times the job has been resubmitted.</p>		
		<h4>Parameters</h4>
		<ul>
					<li>
			<span class="type"><a href="../Grid/Grid.html">Grid</a></span>
			<b>$eg</b> 
			- 
			An open, active grid connection to use</li>
					<li>
			<span class="type">string</span>
			<b>$session_id</b> 
			- 
			The session identifier</li>
					<li>
			<span class="type">string</span>
			<b>$job</b> 
			- 
			<p>The job identifier</p><p>return TRUE if the job was resubmitted, FALSE otherwise.</p></li>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
	<a name="functionsubmit_session_jobs"></a>
	<h3>submit_session_jobs</h3>
	<div class="indent">
		<code>void submit_session_jobs(
string $session_id, mixed $auth)</code>
		<p class="linenumber">[line 298]</p>
		<p align="center"><strong>Submit all session jobs at once to the remote back-end.
</strong></p>
<p>This function expects a session_id which identifies a directory  holding a collection of jobs to be submitted on the local temporary  work directory.</p><p>All jobs are sent to the remote back-end, stored there on the remote  temporary work directory and then launched for execution on the grid.</p><p>Since we are to use a remote back-end connected to the Grid, we need  to know all the authentication details:   	$auth is an array that holds   	    'server' =&gt; user@server identifier   	    'password' =&gt; password to use to connect to 'server'   	    'passphrase' =&gt; passphrase needed to unlock the Grid from 'server'</p><p>In order to convert a session_id into a directory we also need to access  the GLOBALS   	$local_tmp_path   	$gridUI_tmp_path</p><p>As a SIDE EFFECT, the LCG-tools will be installed on the remote temporary  work directory so they may be used for submission, AND BE LEFT there (so  they might be shared by other instances).</p><p>If anything goes wrong, clean up local and remote directories and die.</p><p>XXX JR XXX NOTE: reverse-engineer lcg-submitter and rewrite using PHP</p><h4>Tags:</h4>
<ul>
	<li><b>return</b> - if everything OK, die with an error otherwise.</li>
</ul>
		
		<h4>Parameters</h4>
		<ul>
					<li>
			<span class="type">string</span>
			<b>$session_id</b> 
			- 
			The identifier for our current session</li>
					<li>
			<span class="type">mixed</span>
			<b>$auth</b> 
			- 
			an array holding authentication information</li>
				</ul>
	</div>
	<p class="top">[ <a href="#top">Top</a> ]</p>
</div>
	<div id="credit">
		<hr>
		Documentation generated on Thu, 27 Oct 2005 13:03:37 +0200 by <a href="http://www.phpdoc.org">phpDocumentor 1.2.3</a>
	</div>
</div>
</body>
</html>