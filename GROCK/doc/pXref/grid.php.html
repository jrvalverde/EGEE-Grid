<!doctype html public "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
    <title>PHPXRef 0.4.1 : GridGRAMM v1.00 : Detail view of grid.php</title>
    <link rel="stylesheet" href="/opt/tools/phpxref-0.4.1/sample.css" type="text/css">
    <link rel="stylesheet" href="/opt/tools/phpxref-0.4.1/sample-print.css" type="text/css" media="print">
    <meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
</head>
<body bgcolor="#ffffff" text="#330505" link="#801800" vlink="#300540" alink="#ffffff">
<table class="pagetitle" width="100%">
	<tr>
        <td valign="top" class="pagetitle">
            [ <a href="index.html">Index</a> ]
        </td>
        <td align="right" class="pagetitle">
		    <h2 style="margin-bottom: 0px">PHP Cross Reference of GridGRAMM v1.00</h2>
	    </td>
    </tr>
</table>


<!-- Generated by PHPXref 0.4.1 at Thu Oct 27 13:03:53 2005 -->
<!-- PHPXref (c) 2000-2003 Gareth Watts - gareth@omnipotent.net -->
<!-- http://phpxref.sourceforge.net/ -->

<script src="phpxref.js" type="text/javascript"></script>
<script language="JavaScript" type="text/javascript">
<!--
ext='.html';
relbase='';
subdir='';
filename='grid.php.html';
handleNavFrame(relbase, subdir, filename);
// -->
</script>
<script language="JavaScript" type="text/javascript">
if (gwGetCookie('xrefnav')=='off')
  document.write('<p class="navlinks">[ <a href="javascript:navOn()">Show Explorer<\/a> ]<\/p>');
else
  document.write('<p class="navlinks">[ <a href="javascript:navOff()">Hide Explorer<\/a> ]<\/p>');
</script>
<noscript>
<p class="navlinks">
[ <a href="nav.html" target="_top">Show Explorer</a> ]
[ <a href="index.html" target="_top">Hide Navbar</a> ]
</p>
</noscript>
<script language="JavaScript" type="text/javascript">
<!--
function pesc(str) {
    str=str.replace(/^(con|prn|aux|clock\1nul|lpt\d|com\d)$/i, "-$1");
    str=str.replace(/^(con|prn|aux|clock\1nul|lpt\d|com\d)\./i, "-$1.");
    return str;
}
function jump() {
    if (document.search.classname.value.length) {
		classname=document.search.classname.value.replace(/[()]/g,'');
		classname=document.search.classname.value.toLowerCase();
        window.location=relbase+'_classes/'+escape(escape(pesc(classname)))+ext;
	}
    if (document.search.funcname.value.length) {
		funcname=document.search.funcname.value.replace(/[()]/g,'');
		funcname=document.search.funcname.value.toLowerCase();
        window.location=relbase+'_functions/'+escape(escape(pesc(funcname)))+ext;
	}
    if (document.search.varname.value.length) {
		varname=document.search.varname.value.replace(/[$]/g,'');
        window.location=relbase+'_variables/'+escape(escape(pesc(varname)))+ext;
	}
    if (document.search.tablename.value.length) {
		tablename=document.search.tablename.value.toLowerCase();
        window.location=relbase+'_tables/'+escape(escape(pesc(tablename)))+ext;
	}
    return false;
}

document.writeln('<table align="right" border="0" cellspacing="0" cellpadding="0" class="searchbox">');
document.writeln('<tr><td class="searchbox-title">');
document.writeln('Lookup');
document.writeln('<\/td><\/tr>');

document.writeln('<tr><td class="searchbox-body">');
document.writeln('<form name="search" style="margin:0px; padding:0px" onSubmit=\'return jump()\'>');
document.writeln('<a class="searchbox-body" href="_classes/index.html">Class<\/a>: ');
document.writeln('<input type="text" size=10 value="" name="classname" onChange=\'jump()\'><br>');
document.writeln('<a class="searchbox-body" href="_functions/index.html">Function<\/a>: ');
document.writeln('<input type="text" size=10 value="" name="funcname" onChange=\'jump()\'><br>');
document.writeln('<a class="searchbox-body" href="_variables/index.html">Variable<\/a>: ');
document.writeln('<input type="text" size=10 value="" name="varname" onChange=\'jump()\'><br>');
document.writeln('<a class="searchbox-body" href="_tables/index.html">Table<\/a>: ');
document.writeln('<input type="text" size=10 value="" name="tablename" onChange=\'jump()\'>');
document.writeln('<\/form>');
document.writeln('<\/td><\/tr><\/table>');
// -->
</script>
<div class="details-summary">
<h2><a href="./index.html">/</a> -> <a href="grid.php.source.html">grid.php</a> (summary)</h2>
<p class="viewlinks">[<a href="grid.php.source.html">Source view</a>]
[<a href="javascript:window.print();">Print</a>]</p>
<p><b>Submit jobs to the Grid through a UI-node</b></p>
<table>
<tr><td align="right">Author: </td><td> 	José R. Valverde <jrvalverde@acm.org></td></tr>
<tr><td align="right">File Size: </td><td>1927 lines (69 kb)</td></tr>
<tr><td align="right">Included or required: </td><td>2 times</td></tr>
<tr><td align="right" valign="top">Referenced: </td><td>0 times</td></tr>
<tr><td align="right" valign="top">Includes or requires: </td><td>3 files<br>&nbsp;<a href="util.php.html">util.php</a>
<br>&nbsp;<a href="grid_config.php.html">grid_config.php</a>
<br>&nbsp;<a href="ssh.php.html">ssh.php</a>
</td></tr>
</table>
<h3>Defines 1 class</h3>
<div class="inset">
<p><b>grid::</b> (26 methods):<br>
&nbsp;&nbsp;<a href="#grid">grid</a>()<br>
&nbsp;&nbsp;<a href="#destruct">destruct</a>()<br>
&nbsp;&nbsp;<a href="#set_user">set_user</a>()<br>
&nbsp;&nbsp;<a href="#set_host">set_host</a>()<br>
&nbsp;&nbsp;<a href="#set_password">set_password</a>()<br>
&nbsp;&nbsp;<a href="#set_passphrase">set_passphrase</a>()<br>
&nbsp;&nbsp;<a href="#set_work_dir">set_work_dir</a>()<br>
&nbsp;&nbsp;<a href="#set_error_log">set_error_log</a>()<br>
&nbsp;&nbsp;<a href="#get_connection_status">get_connection_status</a>()<br>
&nbsp;&nbsp;<a href="#get_init_status">get_init_status</a>()<br>
&nbsp;&nbsp;<a href="#connect">connect</a>()<br>
&nbsp;&nbsp;<a href="#initialize">initialize</a>()<br>
&nbsp;&nbsp;<a href="#destroy">destroy</a>()<br>
&nbsp;&nbsp;<a href="#session_new">session_new</a>()<br>
&nbsp;&nbsp;<a href="#session_define">session_define</a>()<br>
&nbsp;&nbsp;<a href="#session_is_valid">session_is_valid</a>()<br>
&nbsp;&nbsp;<a href="#session_directory">session_directory</a>()<br>
&nbsp;&nbsp;<a href="#session_list_all">session_list_all</a>()<br>
&nbsp;&nbsp;<a href="#session_destroy">session_destroy</a>()<br>
&nbsp;&nbsp;<a href="#session_destroy_all">session_destroy_all</a>()<br>
&nbsp;&nbsp;<a href="#job_submit_set_timeout">job_submit_set_timeout</a>()<br>
&nbsp;&nbsp;<a href="#job_submit">job_submit</a>()<br>
&nbsp;&nbsp;<a href="#job_get_id">job_get_id</a>()<br>
&nbsp;&nbsp;<a href="#job_status">job_status</a>()<br>
&nbsp;&nbsp;<a href="#job_get_output">job_get_output</a>()<br>
&nbsp;&nbsp;<a href="#job_cancel">job_cancel</a>()<br>
</p>
</div>
</div>
<br><div class="details-funclist">
<div class="details-classinfo">
<p class="details-classtitle">Class: <a name="grid"><b>grid</b></a>&nbsp;&nbsp;- <a href="_classes/grid.html"><small>X-Ref</small></a>
</p>
<b>Grid access class<BR>
</b><br>
This class allows you to connect to a remote Grid UI server and<BR>
launch and monitor jobs on it.<BR>
<BR>
The reason for this class is mostly one of resilience: if you<BR>
put all your services directly on a GrUI host, then whenever<BR>
that host if offline, your services will be as well.<BR>
<BR>
An alternative is to replicate the services on various GrUI nodes.<BR>
<BR>
Or better yet: use this class and set up your services wherever<BR>
you want. You may put them on an HA system and ensure this way<BR>
their continuous availability. Your service will be always up<BR>
and running, ready to accept jobs.<BR>
<BR>
Your next problem is dealing with the Grid UI. You still need<BR>
to log-in on a Grid access point to submit your jobs. But once<BR>
you have detached from a specific GrUI node, you are free to<BR>
attempt a connection to a given remote access point, and if it<BR>
is available (and while it is) submit jobs as needed. If at any<BR>
time it is not available, nothing is lost: just look for another<BR>
one and use this to continue working. You may thus enter the<BR>
grid through any door.<BR>
<BR>
There is a side advantage too: with your services on a GrUI node<BR>
you can only launch jobs from it. With your services detached from<BR>
any given Grid door, you may use _any_ AND _as many_ as you want:<BR>
this means you may launch jobs using various GrUI nodes simultaneously<BR>
if you so wish. And even split the jobs througho various, separate<BR>
Grids if you feel like it, hence potentially increasing your<BR>
throughput and computing power, harnessing even more resources.<BR>
<BR>
Detaching your jobs from the GrUI has one serious drawback though:<BR>
all your job information must travel from your service user interface<BR>
to the grid user interface through the Internet, which may be<BR>
potentially dangerous. We deal with this security issue using SSH<BR>
to handle all communications and provide encryption. As long as<BR>
you use strong passwords you may feel secure. Actually, it is as<BR>
weak (or strong) as working directly on the GrUI node: access to<BR>
it is still managed by standard password mechanisms and subject to<BR>
the same types of attacks. However, remember you now have an extra<BR>
system (the front-end) to maintain and secure. Please, be always<BR>
cautious with any server you use.<BR>
<BR>
Sounds convincing? Then read ahead to learn how to use this class.<BR>
<BR>
&lt;b&gt;PERSISTENT vs. DISCONNECTED MODE&lt;/b&gt;<BR>
<BR>
As of release 2.0, this distinction is no longer meaningful. We now<BR>
use a new SExec class that multiplexes disconnected commands over a<BR>
single sahred channel, thus providing all the advantages of both,<BR>
connected and disconnected modes. We now provide a single set of<BR>
methods.<BR>
<BR>
&lt;b&gt;JOB MANAGEMENT&lt;/b&gt;<BR>
<BR>
In order to submit your jobs to the grid you need to understand how<BR>
job management has been defined for this class. On the command line<BR>
you would have a lot more versatility, but to make this class more<BR>
useful some compromises had to be reached. We have defined a strict<BR>
protocol to generate/prepare your jobs before submitting them to<BR>
the grid, and you must stick to it if you want to avoid problems.<BR>
<BR>
To understand why this has been designed the way it is, you should<BR>
keep in mind that you will be preparing your jobs on one (or many)<BR>
front-end and submitting them from it to one (or many) GrUI nodes.<BR>
Further to it, this has been designed to make it easy to deploy<BR>
web-based services for users. Therefore many similar jobs might<BR>
be launched simultaneously and we need some way to avoid collusion<BR>
among them. To avoid one job stepping over other we must isolate<BR>
every one from each other. This means providing an isolated environment<BR>
for every job.<BR>
<BR>
The easiest way to achieve our goal is to have every job submitted<BR>
placed on an independent directory (which we pair to the job name).<BR>
For single jobs, this means that you should make sure that no two<BR>
potentially simultaneous/overlapping jobs have the same name (i.e.<BR>
are stored in the same directory so there is no risk one overwrites<BR>
files of the other).<BR>
<BR>
Sometimes this may result inconvenient to you. E.g. if your whole job<BR>
is submitted split into many separate sub-jobs (which each is a separate<BR>
job from the point of view of the grid) you may want to follow some<BR>
naming convention for your sub-jobs that makes it easier to identify<BR>
and keep track of them. In this case, if you had two simultaneous<BR>
runs, then the names would collide.<BR>
<BR>
For example, let's say you are rendering frames of a movie and want<BR>
to identify each job by frame number: 0000, 0001, 0002, 0003... If<BR>
you now try to generate a second movie while the first is being<BR>
processed, then the frames of the second movie (named as well 0000,<BR>
0001, etc...) would overwrite the frames of the first one.<BR>
Generating random names for each frame would be an option, but too<BR>
cumbersome and expensive as you would need to keep track of the<BR>
association of the random names with the actual frames.<BR>
<BR>
To deal with this scenario we define 'sessions'. A session is identified<BR>
by a unique identifier, and guarantees that all jobs belonging to this<BR>
session are kept separate from similarly named jobs from other sessions.<BR>
<BR>
Actually when you create a session, what we actually do is create<BR>
a subdirectory in the GrUI and direct all further jobs to this<BR>
subdirectory. This way, jobs of two sessions may have the same name<BR>
and not step into each other.<BR>
<BR>
&lt;b&gt;PREPARING JOBS FOR THE GRID&lt;/b&gt;<BR>
<BR>
To prepare a job for the grid you must assign it a name. The same<BR>
preacutions that apply to any local job hold for your grid work too:<BR>
if various simultaneous jobs of the same kind may be run, then each<BR>
must be kept separate from the others by using a different name.<BR>
<BR>
Once you have decided the name, you must create a directory locally<BR>
with the same name as your job. In this directory you must install<BR>
everything needed to run your job: executables, libraries, input<BR>
data and a JDL file.<BR>
<BR>
The JDL file defines the work that we will ask the grid to carry<BR>
out. Since each single job gets its own directory, you will only<BR>
submit one JDL file for each, and to make processing easier, we<BR>
request that this JDL file have a fixed name: &quot;job.jdl&quot;.<BR>
<BR>
The grid processing will generate various auxiliary files, for internal<BR>
housekeeping. Again, for simplicity, we have chosen to call each of<BR>
them 'job.*', i.e. 'job.' something. This means that other than 'job.jdl'<BR>
you should NOT create any file named job.anything on your job directory<BR>
to avoid collusion with possible temporary files.<BR>
<BR>
In brief, to prepare a job:<BR>
- select a name<BR>
- create a directory named after the job<BR>
- populate this directory with all files needed to run your job<BR>
- generate the file 'job.jdl' with the description of the work to<BR>
be carried out by the grid<BR>
- avoid having files named 'job.*' (starting with 'job.')<BR>
<BR>
&lt;b&gt;SUBMITTING JOBS TO THE GRID&lt;/b&gt;<BR>
<BR>
First consider whether you will be using unique job names or if<BR>
you will follow a convenient naming convention that may cause name<BR>
collisions with other jobs.<BR>
<BR>
If you feel pretty safe that the job name is unique (e.g. has been<BR>
generated using one or more random strings), then simply call the<BR>
appropriate *job_submit() function.<BR>
<BR>
If you are using names that have low entropy or reusing names for<BR>
similar jobs then it is advisable that you first call one of the<BR>
*session_new() routines to ensure all your jobs will be kept isolated<BR>
from other similarly named jobs, and then use the *job_submit()<BR>
routines to send your jobs.<BR>
<BR>
For the curious: when you submit your job, the directory and all<BR>
of its contents will be sent to the remote Grid UI selected and<BR>
then the 'job.jdl' will be submitted to the grid. In the process,<BR>
several files will be generated holding information about your<BR>
job identity in the grid context that will be kept for housekeeping<BR>
and future reference.<BR>
<BR>
The above is to be kept in mind when submitting light or numerous<BR>
jobs: the transfer time may become sensibly relevant. Please do<BR>
take it into consideration in your equations when designing jobs<BR>
for the grid using this class. You may find it interesting to first<BR>
store all or some of your job data/execs on the grid and keep them<BR>
already there instead of having to copy them.<BR>
<BR>
Grid file management routines are not included yet, but are intended<BR>
for a future release of this class.<BR>
<BR>
<div class="inset"><table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="grid" href="grid.php.source.html#l399">grid</a>()&nbsp;&nbsp;
<a href="_functions/grid.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Constructor for the class<BR>
</b><BR>Set the values for the class variables using defaults provided in<BR>
'config.php'<BR>
<BR>
These defaults can be overridden using the functions provided below.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$eg = new Grid;<BR>
if ($eg == FALSE)<BR>
echo &quot;Couldn't instantiate a new Grid!\n&quot;;<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="destruct" href="grid.php.source.html#l416">destruct</a>()&nbsp;&nbsp;
<a href="_functions/destruct.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><i>No description</i></td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="set_user" href="grid.php.source.html#l464">set_user</a>(<a href="_variables/user.html">$user</a>)&nbsp;&nbsp;
<a href="_functions/set_user.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>set the Grid user name<BR>
</b><BR>In order to connect to the Grid and be able to submit<BR>
jobs we need a tuple (host/user/password/passphrase),<BR>
i.e. an entry point to log in, and a passphrase to unlock<BR>
the grid certificate.<BR>
<BR>
This method allows us to define the username which will<BR>
be used to log in on the grid, i.e. how do we identify<BR>
ourselves to the Grid UI host.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$user=&quot;user&quot;;<BR>
<BR>
$eg = new Grid;<BR>
if ($eg == FALSE)<BR>
echo &quot;Couldn't instantiate a new Grid!\n&quot;;<BR>
$eg-&gt;set_user($user);<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="set_host" href="grid.php.source.html#l501">set_host</a>(<a href="_variables/host.html">$host</a>)&nbsp;&nbsp;
<a href="_functions/set_host.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>set the name of the Grid access host<BR>
</b><BR>In order to connect to the Grid and be able to submit<BR>
jobs we need a tuple (host/user/password/passphrase),<BR>
i.e. an entry point to log in, and a passphrase to unlock<BR>
the grid certificate.<BR>
<BR>
This method allows us to define the entry point to use<BR>
to gain access to the Grid.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$host=&quot;gridui.example.com&quot;;<BR>
<BR>
$eg = new Grid;<BR>
if ($eg == FALSE)<BR>
echo &quot;Couldn't instantiate a new Grid!\n&quot;;<BR>
$eg-&gt;set_host($host);<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="set_password" href="grid.php.source.html#l552">set_password</a>(<a href="_variables/pass.html">$pass</a>)&nbsp;&nbsp;
<a href="_functions/set_password.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>set the password for the remote grid user/server<BR>
</b><BR>In order to connect to the Grid and be able to submit<BR>
jobs we need a tuple (host/user/password/passphrase),<BR>
i.e. an entry point to log in, and a passphrase to unlock<BR>
the grid certificate.<BR>
<BR>
This method allows us to specify the password to<BR>
clear access to the Grid UI host.<BR>
<BR>
Note that this is specific to the remote UI server<BR>
selected.<BR>
<BR>
Further note that gaining access to a user account on<BR>
a given host does not give us rights to submit jobs:<BR>
we still need to unlock our ID certificate with the<BR>
appropriate passphrase. Anybody with root access to an<BR>
UI host can add accounts. Further, the UI host might<BR>
have other roles and host other accounts for different<BR>
purposes which should not access the grid. Bottomline is<BR>
that we can not trust an account on a user-controlled<BR>
host to identify Grid users. For this we need to recurse<BR>
to a central authority to grant final access.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$password=&quot;password&quot;;<BR>
<BR>
$eg = new Grid;<BR>
if ($eg == FALSE)<BR>
echo &quot;Couldn't instantiate a new Grid!\n&quot;;<BR>
$eg-&gt;set_password($password);<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="set_passphrase" href="grid.php.source.html#l599">set_passphrase</a>(<a href="_variables/pass.html">$pass</a>)&nbsp;&nbsp;
<a href="_functions/set_passphrase.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>set the passphrase for the remote grid user<BR>
</b><BR>In order to connect to the Grid and be able to submit<BR>
jobs we need a tuple (host/user/password/passphrase),<BR>
i.e. an entry point to log in, and a passphrase to unlock<BR>
the grid certificate.<BR>
<BR>
After we gain access to the UI host, we must unlock our<BR>
certificate which identifies ourselves as 'bona-fide'<BR>
grid users.<BR>
<BR>
People might have an account on any UI node for a variety<BR>
of reasons, but that does not qualify them to use Grid<BR>
resources. Only a central Grid authority can grant this<BR>
kind of access and this is done by issuing a Certificate.<BR>
<BR>
Users then must store this certificate in their account<BR>
on a UI host and protect it with a suitably long passphrase.<BR>
This last one is the value we provide here.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$passphrase=&quot;pass phrase to unlock certificate&quot;;<BR>
<BR>
$eg = new Grid;<BR>
if ($eg == FALSE)<BR>
echo &quot;Couldn't instantiate a new Grid!\n&quot;;<BR>
$eg-&gt;set_passphrase($passphrase);<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="set_work_dir" href="grid.php.source.html#l630">set_work_dir</a>(<a href="_variables/wd.html">$wd</a>)&nbsp;&nbsp;
<a href="_functions/set_work_dir.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>set working directory on the Grid server<BR>
</b><BR>This is a directory located on the grid server where all jobs<BR>
and job related information will be created. It may be a path<BR>
local to the user home or a global path (usually on /tmp or<BR>
/var/tmp).<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$eg = new Grid;<BR>
if ($eg == FALSE)<BR>
echo &quot;Couldn't instantiate a new Grid!\n&quot;;<BR>
$eg-&gt;set_work_dir(&quot;./grid-services&quot;);<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="set_error_log" href="grid.php.source.html#l657">set_error_log</a>(<a href="_variables/errlog.html">$errlog</a>)&nbsp;&nbsp;
<a href="_functions/set_error_log.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>set error log<BR>
</b><BR>Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$eg = new Grid;<BR>
if ($eg == FALSE)<BR>
echo &quot;Couldn't instantiate a new Grid!\n&quot;;<BR>
$eg-&gt;set_error_log(&quot;./grid-services/error.log&quot;);<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="get_connection_status" href="grid.php.source.html#l690">get_connection_status</a>()&nbsp;&nbsp;
<a href="_functions/get_connection_status.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>get grid connection status<BR>
</b><BR>This method allows you to know if the connection with the remote<BR>
grid entry point has been successfully established or not. Note<BR>
that this does not mean you may launch jobs to the grid: you<BR>
still need to initialize the grid first.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$eg = new Grid;<BR>
<BR>
$eg-&gt;pconnect();<BR>
if ($eg-&gt;get_connection_status() == FALSE)<BR>
echo &quot;Couldn't connect to the Grid entry point!\n&quot;;<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="get_init_status" href="grid.php.source.html#l731">get_init_status</a>()&nbsp;&nbsp;
<a href="_functions/get_init_status.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>get grid initialization status<BR>
</b><BR>This method allows you to learn whether the Grid has been<BR>
successfully initialized and is ready to accept jobs. This<BR>
entails both, login in as a specific user on the Grid connection<BR>
point, and activating the proxy with your passphrase.<BR>
<BR>
The reason for the two step process is that in order to activate<BR>
the grid you need to identify yourself using a grid certificate<BR>
emitted by a CA. But to activate it you need an account on a grid<BR>
access machine, which is open by any local administrator. Since<BR>
this account is not under the central CA control, we can't trust<BR>
it to submit jobs and require a proxy-initialization with an<BR>
appropriate passphrase.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$eg = new Grid;<BR>
<BR>
$eg-&gt;initialize();<BR>
if ($eg-&gt;get_init_status() == FALSE)<BR>
echo &quot;Couldn't initialize the Grid!\n&quot;;<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="connect" href="grid.php.source.html#l788">connect</a>()&nbsp;&nbsp;
<a href="_functions/connect.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>open a persistent connection to the Grid UI server<BR>
</b><BR>The Grid User Interface Server is the entry point to the Grid<BR>
for users and user applications. This is where jobs are launched from.<BR>
<BR>
This package has been designed to be able to be installed in any<BR>
host, independent of whether it is an UI or not. Thus, to be able to<BR>
submit jobs to the Grid, the server hosting the Web UI must connect to<BR>
a Grid UI host to do the work.<BR>
<BR>
This routine opens a connection to a Grid UI host using an specified<BR>
username (i.e. all jobs will be run under said username).<BR>
<BR>
The panorama therefore will look like this:<BR>
<BR>
HTML front-end --&gt; processor.php &lt;--&gt; SSH &lt;--&gt; remote host &lt;--&gt; Grid<BR>
<BR>
This allows for better resilience: should a GridUI host be<BR>
unavailable, we can detect the error condition and try another<BR>
one. If the GridUI runs the front-end, then we have a single<BR>
point of failure, which is a no-no.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
require_once './grid_config.php';<BR>
require_once './ssh.php';<BR>
require_once './grid.php';<BR>
<BR>
$eg = new Grid;<BR>
<BR>
$eg-&gt;pconnect();<BR>
if ($eg-&gt;get_connection_status() == FALSE)<BR>
echo &quot;Couldn't instantiate a new Grid!\n&quot;;<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="initialize" href="grid.php.source.html#l895">initialize</a>(<a href="_variables/hours.html">$hours</a>=12, <a href="_variables/minutes.html">$minutes</a>=0)&nbsp;&nbsp;
<a href="_functions/initialize.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Start the Grid services<BR>
</b><BR>This function starts the grid services on the remote UI server host.<BR>
This is done by unlocking the certificate that we are going to use<BR>
to run our jobs on the grid using the passphrase provided.<BR>
<BR>
Grid services have a lifetime of their own. By default they are<BR>
available for 12:00 hours (that's the default value of<BR>
grid-proxy-init itself), but their duration may be fine tuned<BR>
if we have some knowledge about the time required to run our<BR>
job.<BR>
<BR>
Grid opening time is specified in hours+minutes. If the number of<BR>
minutes is negative, the specified minutes are substracted from<BR>
the specified hours (e.g: 1, -15 is fifteen minutes to one hour,<BR>
i.e. 45 minutes). If the total time specified is negative then<BR>
the default of 12:00 is used.<BR>
<BR>
Grid::initialize() enables the grid for a specified amount of time<BR>
(by default 12:00h). This means that during the validity period,<BR>
the user on the Grid-UI host may access the grid, in the same or<BR>
different logins. The validity period SURVIVES after we close<BR>
all communications with the remote grid entry point for as long<BR>
as we have specified (so our jobs may continue running).<BR>
<BR>
If Grid access was already available (by a previous call to<BR>
Grid::initialize()) when we issue the call, then it is reused<BR>
and extended to acommodate the newly requested validity period.<BR>
In other words, the Grid access is shared among all logins<BR>
during its lifetime.<BR>
<BR>
This also means that if a valid certificate has been issued and<BR>
not expired yet (another call to Grid::initialize() is still<BR>
valid), then we may submit jobs to the Grid without any need<BR>
to call Grid::initialize() ourselves.<BR>
<BR>
E.g., say you have a web-based service that runs a long job<BR>
and you want to have the grid enabled 12h (the default). You<BR>
just call Grid::initialize() and then submit the job.<BR>
<BR>
Now say that before it expires, someone logs in on your account<BR>
but shouldn't have access to the Grid (i.e. they don't know<BR>
the Grid-activation passphrase). Since the grid is already<BR>
activated, they CAN submit jobs on your behalf even if they<BR>
should not.<BR>
<BR>
Therefore, &lt;b&gt;DO NOT SHARE YOUR ACCOUNT ON THE GRID-UI<BR>
WITH ANYBODY&lt;/b&gt;. Protect it as dearly as your Grid certificate.<BR>
<BR>
It also means that debugging may be somewhat convoluted, as<BR>
a call to Grid::initialize() may fail and jobs could still<BR>
be accepted if another call from some other process is still<BR>
valid. While debugging, it is better if you review the<BR>
command output and make sure it shows how the call fared.<BR>
<BR>
So, what happens if we destroy a session? See Grid::destroy()<BR>
for more details.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
$eg = new Grid;<BR>
$eg-&gt;set_user($user);<BR>
$eg-&gt;set_host($host);<BR>
$eg-&gt;set_password($passwd);<BR>
$eg-&gt;set_passphrase($passphrase);<BR>
$eg-&gt;set_work_dir(&quot;/tmp/grid/test/cless&quot;);<BR>
$eg-&gt;set_error_log(&quot;/tmp/grid/test/cless/connection.err&quot;);<BR>
$eg-&gt;connect();<BR>
if (!$eg-&gt;initialize())<BR>
echo &quot;error: couldn't init the grid\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
$eg-&gt;destroy();<BR>
$eg-&gt;disconnect();<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="destroy" href="grid.php.source.html#l1025">destroy</a>()&nbsp;&nbsp;
<a href="_functions/destroy.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Destroy remote grid identity<BR>
</b><BR>Destroy the certification we initialized so that no more jobs<BR>
can be launched under our identity.<BR>
<BR>
This may be called even if we haven't called 'Grid::initialize()'<BR>
because there may exits a previous activation that is still<BR>
valid and we want to destroy it.<BR>
<BR>
To make things clear:<BR>
<BR>
Grid::initialize() &quot;opens&quot; the &quot;door&quot; to the Grid for &lt;i&gt;the user&lt;/i&gt;<BR>
during a given time. New calls from the same user in this or any<BR>
other login session, from this or any other site, while the &quot;door&quot;<BR>
is open, share the same &quot;door&quot; and simply extend its validity<BR>
period.<BR>
<BR>
Grid::destroy() &quot;closes&quot; the currently open door. If the door<BR>
was being shared by more login sessions, it is closed for &lt;i&gt;all&lt;/i&gt;<BR>
of them, not just the caller, and hence nor the caller, nor<BR>
&lt;i&gt;any process&lt;/i&gt; under the same user will be able to use the<BR>
grid any longer unless Grid::initialize() is called again to<BR>
open the door again (issue a new certificate).<BR>
<BR>
In other words, you don't close &lt;i&gt;a&lt;/i&gt; Grid &quot;door&quot;, you close<BR>
&lt;i&gt;the&lt;/i&gt; Grid &quot;door&quot;, and if it casually is being shared with other<BR>
work sessions, then ALL of them will be destroyed (meaning that<BR>
other active work sessions will fail).<BR>
<BR>
Thus: be careful when using this method. Be &lt;b&gt;very careful&lt;/b&gt;.<BR>
<BR>
Sessions should be initiated using a validity length that you<BR>
guesstimate will be comfortably enough for running all your work<BR>
and left to expire by themselves.<BR>
<BR>
Grid::destroy() should only be called when you are sure that<BR>
you don't want &lt;i&gt;any&lt;/i&gt; work on the Grid to be accepted on<BR>
your behalf, neither from this not other work sessions.<BR>
<BR>
So, in general, it is better to make good estimations of the<BR>
time needed by your jobs and specify it to Grid::initialize()<BR>
and not use Grid::destroy() unless there are good reasons.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
$eg = new Grid;<BR>
$eg-&gt;set_user($user);<BR>
$eg-&gt;set_host($host);<BR>
$eg-&gt;set_password($passwd);<BR>
$eg-&gt;set_passphrase($passphrase);<BR>
$eg-&gt;set_work_dir(&quot;/tmp/grid/test/cless&quot;);<BR>
$eg-&gt;set_error_log(&quot;/tmp/grid/test/cless/connection.err&quot;);<BR>
if (!$eg-&gt;initialize())<BR>
echo &quot;error: couldn't init the grid\n&quot;;<BR>
else<BR>
echo &quot;OK&quot;;<BR>
$eg-&gt;destroy();<BR>
$eg-&gt;disconnect();<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="session_new" href="grid.php.source.html#l1181">session_new</a>(<a href="_variables/hint.html">$hint</a>=&quot;sess&quot;)&nbsp;&nbsp;
<a href="_functions/session_new.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Create a new session<BR>
</b><BR>We take control of the session system: in a previous incarnation<BR>
we got the session name from the user. This is dangerous since we<BR>
can not avoid clashes even with random session names provided by<BR>
a user: a randomly generated name may be guaranteed unique within<BR>
the user's local host namespace, but should various calls come from<BR>
different hosts (e.g. HA front-ends in a cluster), it is conceivable<BR>
(although improbable) that both come up with the same random number<BR>
and generate a clash on the shared remote grid access point. Hence<BR>
the new approach: to be true, users do not need to generate a session<BR>
name themselves: they just need a way to refer to them.<BR>
<BR>
This routine will generate a new session: under a given session,<BR>
we guarantee that processes will be run under an isolated sandbox<BR>
where non name clashes from other concurrent users will occur.<BR>
Name clashes within a given session induced by the user are still<BR>
the responsability of the user.<BR>
<BR>
SESSIONS<BR>
<BR>
The basic idea is as follows: if you are developing a service that<BR>
may be called concurrently by various users, your problem at the GrUI<BR>
is the same as on your local server: avoiding name clashes for jobs.<BR>
As long as you manage that locally using unique names, the same will<BR>
work on the UI server.<BR>
<BR>
This however may be inconvenient at times. It is usually the case<BR>
when your service is not composed by a single job, but by many<BR>
independent jobs that may be run concurrently as well. You still<BR>
need to generate unique names for each sub-job, but if they are<BR>
produced within a local uniquely named service-instance, then you<BR>
may reuse the sub-job names for each instance.<BR>
<BR>
This comes handy in the case of many sub-jobs: as long as the main<BR>
service instance is uniquely identified, contained sub-jobs may have<BR>
significant names that are easier to identify than randomly-generated<BR>
ones: e.g.<BR>
&lt;pre&gt;<BR>
user A -&gt; service-instance-A -+-&gt; sub-job-1<BR>
|<BR>
+-&gt; sub-job-2<BR>
|<BR>
etc...<BR>
<BR>
user B -&gt; service-instance-B -+-&gt; sub-job-1<BR>
|<BR>
+-&gt; sub-job-2<BR>
|<BR>
etc...<BR>
&lt;/pre&gt;<BR>
In this case, since the service-instances have unique names (A, B)<BR>
we may use the same naming strategy in both cases for naming sub-jobs<BR>
(1, 2,...) which makes bookkeeping a lot easier.<BR>
<BR>
To reproduce a similar behaviour remotely we provide 'sessions'.<BR>
<BR>
Basically, what you are doing in the local case is isolating all the<BR>
equally named jobs of each service-instance within an unique sandbox.<BR>
In the grid you get the same result using 'sessions': whenever you<BR>
want to submit a series of non-randomly-named jobs (or even a single<BR>
one) you first allocate a session, and then attach those jobs to the<BR>
session. Job names within a session are guaranteed not to clash with<BR>
equal job names from another session.<BR>
<BR>
Note the 'non-randomly-named' tag above: you want to use sessions<BR>
ALWAYS that you use any non-random job name unless you can guarantee<BR>
it will be the only job with that name ON THE GRID.<BR>
<BR>
This is an important notice: your job may have a non-random, but<BR>
guaranteed unique name on your local host. And as long as the job<BR>
will only be submitted from your local host it is OK. But if you<BR>
are going to share your tools with other fellows, then they will<BR>
install them locally and submit a similarly named job as well. The<BR>
job name will be unique within each one's local machine, but when<BR>
jobs are collected at the GrUI, they will all have the same name,<BR>
which is a no-no.<BR>
<BR>
USING SESSIONS<BR>
<BR>
Once you see the need for using sessions, using them is quite<BR>
simple: you call this function asking for a new session to be<BR>
created on the remote grid access point on your behalf. The routine<BR>
will return a unique session identifier which you later use to<BR>
tag jobs that are to be run within that session's sandbox.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
$eg = new Grid;<BR>
$eg-&gt;set_user($user);<BR>
$eg-&gt;set_host($host);<BR>
$eg-&gt;set_password($passwd);<BR>
$eg-&gt;set_passphrase($passphrase);<BR>
$eg-&gt;set_work_dir(&quot;/tmp/grid/debug&quot;);<BR>
$eg-&gt;set_error_log(&quot;/tmp/grid/debug/connection.err&quot;);<BR>
echo &quot;initializing grid... &quot;;<BR>
if (!$eg-&gt;initialize()) {<BR>
echo &quot;error: couldn't init the grid\n&quot;;<BR>
exit;<BR>
}<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
echo &quot;Submitting tst-job to default session...\n&quot;;<BR>
$out = array(&quot;&quot;);<BR>
if (! $eg-&gt;job_submit(&quot;tst-job&quot;, $out)) {<BR>
echo &quot;error: coudn't start the job\n&quot;;<BR>
exit;<BR>
}<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
print_r($out);<BR>
echo &quot;Submitting tst-job to a new session...\n&quot;;<BR>
$sess = $eg-&gt;session_new();<BR>
echo &quot;sess = &quot;; print_r($sess); echo &quot;\n&quot;;<BR>
if ($sess != FALSE) {<BR>
$out = array(&quot;&quot;);<BR>
if (! $eg-&gt;job_submit(&quot;tst-job&quot;, $out, $sess))<BR>
echo &quot;error: coudn't start the job\n&quot;;<BR>
else {<BR>
echo &quot;OK\n&quot;;<BR>
}<BR>
$eg-&gt;session_destroy($sess);<BR>
}<BR>
$eg-&gt;destruct();<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="session_define" href="grid.php.source.html#l1251">session_define</a>(<a href="_variables/session.html">$session</a>, <a href="_variables/directory.html">$directory</a>)&nbsp;&nbsp;
<a href="_functions/session_define.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Define an already existing session<BR>
</b><BR>This is useful if the session already exists and<BR>
we want to access it: we already know its<BR>
directory name, and just want to associate a<BR>
new name with the existing directory name.<BR>
<BR>
Use e.g. when you are to submit a job from<BR>
a WWW page and access the results from a different<BR>
one: as the new page has no access to the status of<BR>
the previous one, we need to rebuild it ourselves.<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="session_is_valid" href="grid.php.source.html#l1266">session_is_valid</a>(<a href="_variables/session.html">$session</a>='default')&nbsp;&nbsp;
<a href="_functions/session_is_valid.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>check if supplied argument is a valid (existing and active)<BR>
session.<BR>
</b><BR></td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="session_directory" href="grid.php.source.html#l1287">session_directory</a>(<a href="_variables/session.html">$session</a>='default')&nbsp;&nbsp;
<a href="_functions/session_directory.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>return the directory associated to a session<BR>
</b><BR>DOES NO ERROR CHECKING FOR VALID SESSION<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="session_list_all" href="grid.php.source.html#l1299">session_list_all</a>()&nbsp;&nbsp;
<a href="_functions/session_list_all.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>list all existing sessions<BR>
(debugging only)<BR>
</b><BR></td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="session_destroy" href="grid.php.source.html#l1321">session_destroy</a>(<a href="_variables/session.html">$session</a>='default')&nbsp;&nbsp;
<a href="_functions/session_destroy.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>destroy the specified session<BR>
</b><BR>This method destroys all data associated with the specified<BR>
session. Currently it does not kill its associated jobs, but<BR>
deleted all their underlying data nevertheless.<BR>
<BR>
Warning: passing an empty string or no argument will destroy<BR>
the default session.<BR>
<BR>
return bool TRUE if success, FALSE otherwise<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="session_destroy_all" href="grid.php.source.html#l1354">session_destroy_all</a>()&nbsp;&nbsp;
<a href="_functions/session_destroy_all.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Destroy all existing sessions<BR>
</b><BR></td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="job_submit_set_timeout" href="grid.php.source.html#l1397">job_submit_set_timeout</a>(<a href="_variables/seconds.html">$seconds</a>=0)&nbsp;&nbsp;
<a href="_functions/job_submit_set_timeout.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Set maximum (guesstimated) allowed time for a job submission to<BR>
succeed.<BR>
</b><BR>This value is application and dataset dependent, will be of<BR>
relevance in rare occasions (1/4000) and hence may as well be<BR>
generous.<BR>
<BR>
The default is 0 seconds (no timeout). You should make measures<BR>
to ensure it is reasonable. If set to 0, no timeout will be used.<BR>
<BR>
Unless set to 0, you will need to code some resubmission policy<BR>
in your application.<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="job_submit" href="grid.php.source.html#l1455">job_submit</a>(<a href="_variables/job.html">$job</a>, &amp;<a href="_variables/out.html">$out</a>, <a href="_variables/session.html">$session</a>='default')&nbsp;&nbsp;
<a href="_functions/job_submit.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>submit a job to the grid<BR>
</b><BR>This procedure submits a job to the Grid, optionally tagging it<BR>
as part of a specific session.<BR>
<BR>
A job must be stored in a single directory (whose name you<BR>
provide in the call to this function). The directory must contain<BR>
any executables, libraries, configuration files/scripts, and input<BR>
data needed to run your job.<BR>
<BR>
In addition, there must be a JDL file called 'job.jdl' and describing<BR>
the job to the grid using the JDL language.<BR>
<BR>
Please note that only the job-directory name is used. If you provide<BR>
a longer path, only the last component (the job directory name) will<BR>
be used to identify your job remotely.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
$eg = new Grid;<BR>
$eg-&gt;set_user($user);<BR>
$eg-&gt;set_host($host);<BR>
$eg-&gt;set_password($passwd);<BR>
$eg-&gt;set_passphrase($passphrase);<BR>
$eg-&gt;set_work_dir(&quot;/tmp/grid/test/cless&quot;);<BR>
$eg-&gt;set_error_log(&quot;/tmp/grid/test/cless/connection.err&quot;);<BR>
echo &quot;initializing grid... &quot;;<BR>
if (!$eg-&gt;initialize())<BR>
echo &quot;error: couldn't init the grid\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
echo &quot;Submitting tst-job... &quot;;<BR>
if (! $eg-&gt;job_submit(&quot;tst-job&quot;, $out))<BR>
echo &quot;error: coudn't start the job\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
print_r($out);<BR>
$eg-&gt;destroy();<BR>
$eg-&gt;disconnect();<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="job_get_id" href="grid.php.source.html#l1597">job_get_id</a>(<a href="_variables/job.html">$job</a>, <a href="_variables/session.html">$session</a>='default')&nbsp;&nbsp;
<a href="_functions/job_get_id.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Get Grid ID of a submitted job.<BR>
</b><BR>You should not need this function normally. The job and session<BR>
names you already have should actually be enough for all your needs.<BR>
The function is needed internally by the class, but otherwise it should<BR>
be of little interest.<BR>
<BR>
Nevertheless, you may want to have access to this knowledge, either<BR>
out of curiosity or for other reasons (e.g. re-routing access to a<BR>
job through other access points after a crash of the original access<BR>
point you used to submit it).<BR>
<BR>
Indeed, this will come handy for newer releases of this class when<BR>
disaster recovery is added. Meanwhile, as already said, it is of little<BR>
use.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
$eg = new Grid;<BR>
$eg-&gt;set_user($user);<BR>
$eg-&gt;set_host($host);<BR>
$eg-&gt;set_password($passwd);<BR>
$eg-&gt;set_passphrase($passphrase);<BR>
$eg-&gt;set_work_dir(&quot;/tmp/grid/test/cless&quot;);<BR>
$eg-&gt;set_error_log(&quot;/tmp/grid/test/cless/connection.err&quot;);<BR>
echo &quot;initializing grid... &quot;;<BR>
if (!$eg-&gt;initialize())<BR>
echo &quot;error: couldn't init the grid\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
echo &quot;Submitting tst-job... &quot;;<BR>
if (! $eg-&gt;job_submit(&quot;tst-job&quot;, $out))<BR>
echo &quot;error: coudn't start the job\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
print_r($out);<BR>
print_r($eg-&gt;job_get_id(&quot;tst-job&quot;));<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="job_status" href="grid.php.source.html#l1692">job_status</a>(<a href="_variables/job.html">$job</a>, &amp;<a href="_variables/out.html">$out</a>, <a href="_variables/session.html">$session</a>='default')&nbsp;&nbsp;
<a href="_functions/job_status.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>check job status<BR>
</b><BR>This routine retrieves the job status report from the remote<BR>
grid entry point into your local job directory, and returns the<BR>
status of your specified job/session.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
$eg = new Grid;<BR>
$eg-&gt;set_user($user);<BR>
$eg-&gt;set_host($host);<BR>
$eg-&gt;set_password($passwd);<BR>
$eg-&gt;set_passphrase($passphrase);<BR>
$eg-&gt;set_work_dir(&quot;/tmp/grid/test/cless&quot;);<BR>
$eg-&gt;set_error_log(&quot;/tmp/grid/test/cless/connection.err&quot;);<BR>
echo &quot;initializing grid... &quot;;<BR>
if (!$eg-&gt;initialize())<BR>
echo &quot;error: couldn't init the grid\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
echo &quot;Submitting tst-job... &quot;;<BR>
if (! $eg-&gt;job_submit(&quot;tst-job&quot;, $out))<BR>
echo &quot;error: coudn't start the job\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
print_r($out);<BR>
echo &quot;\nGetting job ID... \n&quot;;<BR>
print_r($eg-&gt;job_get_id(&quot;tst-job&quot;));<BR>
echo &quot;\nGetting job status... \n&quot;;<BR>
print_r($eg-&gt;job_status(&quot;tst-job&quot;, $out));<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="job_get_output" href="grid.php.source.html#l1806">job_get_output</a>(<a href="_variables/job.html">$job</a>, &amp;<a href="_variables/out.html">$out</a>, <a href="_variables/session.html">$session</a>='default')&nbsp;&nbsp;
<a href="_functions/job_get_output.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>retrieve results<BR>
</b><BR>Retrieve the results of a job from the Grid. This function will<BR>
attempt to retrieve the results of a job. This relies on the results<BR>
being already available, i.e. you better check the job status first<BR>
and make sure it has completed.<BR>
<BR>
If you don't, and the job hasn't completed yet, don't worry: nothing<BR>
will be retrieved. So, no harm done. But you should check stdout to<BR>
verify the condition.<BR>
<BR>
All results will be stored remotely on the job directory, under a<BR>
subdirectory with a unique name of the form $grid_user_name_XXXXX...<BR>
where the X's mean a random string. Locally you will see them as<BR>
$job/job_output so that they have an easy name to identify them.<BR>
<BR>
To access your job output, just open this $job/output directory<BR>
and look inside.<BR>
<BR>
The rationale for this is to avoid overwriting your job information<BR>
with its output. If that was intended, nothing is lost, just pick-up<BR>
the newly generated file. This way you always have continued access<BR>
to your old, submitted data for checking.<BR>
<BR>
Sample usage:<BR>
&lt;code&gt;<BR>
$eg = new Grid;<BR>
$eg-&gt;set_user($user);<BR>
$eg-&gt;set_host($host);<BR>
$eg-&gt;set_password($passwd);<BR>
$eg-&gt;set_passphrase($passphrase);<BR>
$eg-&gt;set_work_dir(&quot;/tmp/grid/test/cless&quot;);<BR>
$eg-&gt;set_error_log(&quot;/tmp/grid/test/cless/connection.err&quot;);<BR>
echo &quot;initializing grid... &quot;;<BR>
if (!$eg-&gt;initialize())<BR>
echo &quot;error: couldn't init the grid\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
echo &quot;Submitting tst-job... &quot;;<BR>
if (! $eg-&gt;job_submit(&quot;tst-job&quot;, $out))<BR>
echo &quot;error: coudn't start the job\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
print_r($out);<BR>
echo &quot;\nGetting job ID... \n&quot;;<BR>
print_r($eg-&gt;job_get_id(&quot;tst-job&quot;));<BR>
echo &quot;\nGetting job status... \n&quot;;<BR>
print_r($eg-&gt;job_status(&quot;tst-job&quot;, $out));<BR>
echo &quot;\nGetting job output... &quot;;<BR>
if (! $eg-&gt;job_get_output(&quot;tst-job&quot;, $out))<BR>
echo &quot;error: couldn't get job output\n&quot;;<BR>
else<BR>
echo &quot;OK\n&quot;;<BR>
print_r($out);<BR>
&lt;/code&gt;<BR>
<BR>
</td></tr></table>

<br>
<table border="0" width="80%" class="funcinfo"><tr class="funcinfo-title"><td>
<a name="job_cancel" href="grid.php.source.html#l1896">job_cancel</a>(<a href="_variables/job.html">$job</a>, &amp;<a href="_variables/out.html">$out</a>, <a href="_variables/session.html">$session</a>='default')&nbsp;&nbsp;
<a href="_functions/job_cancel.html"><small>X-Ref</small></a>
</td></tr><tr class="funcinfo-body"><td><b>Cancel a job previously submitted to the grid<BR>
</b><BR>Note: If the job has not reached the CE yet (i.e.: its status is WAITING<BR>
or READY states), the cancellation request may be ignored, and the job<BR>
may continue running, although a message of successful cancellation is<BR>
returned to the user. In such cases, just cancel the job again when its<BR>
status is SCHEDULED or RUNNING<BR>
<BR>
</td></tr></table>

<br>
</div>
</div>

</div>
<!-- A link to the phpxref site in your customized footer file is appreciated ;-) -->
<br><hr>
<table width="100%">
	<tr><td>Generated: Thu Oct 27 13:03:53 2005</td>
	<td align="right"><i>Cross-referenced by <a href="http://phpxref.sourceforge.net/">PHPXref 0.4.1</a></i></td>
	</tr>
</table>
</body></html>
