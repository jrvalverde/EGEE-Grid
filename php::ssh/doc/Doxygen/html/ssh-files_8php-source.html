<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>php::ssh: ssh-files.php Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>ssh-files.php</h1><a href="ssh-files_8php.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 &lt;?php
00002 
00003 <span class="comment">/* vim: set expandtab tabstop=4 shiftwidth=4 softtabstop=4: */</span>
00004 <span class="comment"></span>
00005 <span class="comment">/**</span>
00006 <span class="comment"> * ssh.php -- a class to execute remote commands over SSH</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> *      This file contains the files-based implementation of the SExec</span>
00009 <span class="comment"> * class. This implementation relies on the usage of regular temporary</span>
00010 <span class="comment"> * files to communicate with the remote end, thus avoiding several</span>
00011 <span class="comment"> * drawbacks (mainly deadlocks) associated with pipes.</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *      The SExec class provides methods to launch and control jobs and</span>
00014 <span class="comment"> * transfer files over SSH.</span>
00015 <span class="comment"> *</span>
00016 <span class="comment"> * PHP versions 4 and 5</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> * LICENSE:</span>
00019 <span class="comment"> * This library is free software; you can redistribute it and/or</span>
00020 <span class="comment"> * modify it under the terms of the GNU Lesser General Public</span>
00021 <span class="comment"> * License as published by the Free Software Foundation; either</span>
00022 <span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span>
00023 <span class="comment"> * </span>
00024 <span class="comment"> * This library is distributed in the hope that it will be useful,</span>
00025 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00026 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
00027 <span class="comment"> * Lesser General Public License for more details.</span>
00028 <span class="comment"> * </span>
00029 <span class="comment"> * You should have received a copy of the GNU Lesser General Public</span>
00030 <span class="comment"> * License along with this library; if not, write to the Free Software</span>
00031 <span class="comment"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> * @category    Net</span>
00034 <span class="comment"> * @package     SExec</span>
00035 <span class="comment"> * @author      José R. Valverde &lt;jrvalverde@acm.org&gt;</span>
00036 <span class="comment"> * @copyright   José R. Valverde &lt;jrvalverde@es.embnet.org&gt;</span>
00037 <span class="comment"> * @license     doc/lic/</span>
00038 <span class="comment"> * @version     CVS: $Id: ssh-files.php,v 1.6 2005/05/25 16:02:40 netadmin Exp $</span>
00039 <span class="comment"> * @link        http://savannah.cern.ch/projects/GridGRAMM</span>
00040 <span class="comment"> * @see         ssh(1), scp(1)</span>
00041 <span class="comment"> * @since       File available since Release 1.0</span>
00042 <span class="comment"> */</span>
00043 
00044 <span class="comment"></span>
00045 <span class="comment">/** </span>
00046 <span class="comment"> * Allow for remote execution of commands using SSH</span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> *      The SExec class provides a number of facilities for remote</span>
00049 <span class="comment"> * command execution using SSH.</span>
00050 <span class="comment"> *</span>
00051 <span class="comment"> *      The name SExec comes after "rexec" (the remote execution library)</span>
00052 <span class="comment"> * and the "exec" facilities available under PHP. As a matter of fact,</span>
00053 <span class="comment"> * we try to mimic to some extent the execution facilities offered by</span>
00054 <span class="comment"> * PHP over SSH: thus you will find ssh_popen() akin to popen(), etc.</span>
00055 <span class="comment"> *</span>
00056 <span class="comment"> * &lt;b&gt;RATIONALE&lt;/b&gt;</span>
00057 <span class="comment"> *</span>
00058 <span class="comment"> *      The reason for this class is to allow executing code on a remote</span>
00059 <span class="comment"> * back-end avoiding MITM spoofs in your communications. This allows you</span>
00060 <span class="comment"> * to provide a web front-end (possibly redundant) and call a remote</span>
00061 <span class="comment"> * back-end to execute the job.</span>
00062 <span class="comment"> *</span>
00063 <span class="comment"> *      Furthermore, you may have fallback features where if execution</span>
00064 <span class="comment"> * on a remote back-end fails you can restart the command on a fallback</span>
00065 <span class="comment"> * remote host, increasing reliability.</span>
00066 <span class="comment"> *</span>
00067 <span class="comment"> * &lt;b&gt;DEPENDENCIES&lt;/b&gt;</span>
00068 <span class="comment"> *</span>
00069 <span class="comment"> *      The class relies on an underlying installation of SSH. It has</span>
00070 <span class="comment"> * been tested with OpenSSH on Linux, but should work on other systems</span>
00071 <span class="comment"> * with OpenSSH as well.</span>
00072 <span class="comment"> *</span>
00073 <span class="comment"> *      Further, the class in its current inception relies on OpenSSH</span>
00074 <span class="comment"> * version being greater than 3.8. If you have an older SSH, please use</span>
00075 <span class="comment"> * version 1.0 of this class instead.</span>
00076 <span class="comment"> *</span>
00077 <span class="comment"> * &lt;b&gt;DESIGN RATIONALE&lt;/b&gt;</span>
00078 <span class="comment"> *</span>
00079 <span class="comment"> *      The reasons for the choices taken are simple: we might have</span>
00080 <span class="comment"> * relied on an SSH library (like libSSH) and integrated it with PHP,</span>
00081 <span class="comment"> * but then, any weakness/bug/change on said library would require a</span>
00082 <span class="comment"> * recompilation of the library and PHP. This is a serious inconvenience.</span>
00083 <span class="comment"> * More to that, it would require the maintenance of two simultaneous</span>
00084 <span class="comment"> * SSH installations, viz. OpenSSH and the library, duplicating the work</span>
00085 <span class="comment"> * of tracking security/bug issues.</span>
00086 <span class="comment"> *</span>
00087 <span class="comment"> *      By using the underlying SSH commands, we become independent of</span>
00088 <span class="comment"> * them: if anything is discovered, you just have to update your system</span>
00089 <span class="comment"> * SSH, and nothing else. Otherwise you would have a dependency on SSH</span>
00090 <span class="comment"> * to remember, which is always forgotten. This way we avoid getting out</span>
00091 <span class="comment"> * of sync with the system's SSH.</span>
00092 <span class="comment"> *</span>
00093 <span class="comment"> *      Better yet: this easies development, making this class a lot</span>
00094 <span class="comment"> * simpler to write, understand, maintain and debug.</span>
00095 <span class="comment"> *</span>
00096 <span class="comment"> *      Finally, the dependency on SSH being OpenSSH 3.8 or greater is</span>
00097 <span class="comment"> * due to efficiency reasons. Establishing an SSH connection is costly</span>
00098 <span class="comment"> * in time. If you are going to make many, this would impose a heavy</span>
00099 <span class="comment"> * cost on your scripts. We routinely launch several thousand remote </span>
00100 <span class="comment"> * jobs, and authentication delays soon proved unacceptable.</span>
00101 <span class="comment"> *</span>
00102 <span class="comment"> *      OpenSSH 3.8 introduced the possibility of sharing a single SSH</span>
00103 <span class="comment"> * channel between many "connections". This means that only the first</span>
00104 <span class="comment"> * (or master) instance (which will provide the shared channel) needs </span>
00105 <span class="comment"> * to authenticate, hence saving significant time.</span>
00106 <span class="comment"> *</span>
00107 <span class="comment"> *      The constructor then creates a master channel, leaves it idle</span>
00108 <span class="comment"> * all the object's lifetime and closses it at the end. This channel</span>
00109 <span class="comment"> * might be used as well, but we felt it wasn't such a big loss to keep</span>
00110 <span class="comment"> * it idle, and furthermore, being the master, we didn't want to risk</span>
00111 <span class="comment"> * getting into any trouble that might close it prematurely. So it stands.</span>
00112 <span class="comment"> *</span>
00113 <span class="comment"> *      All other routines (which actually do the work) simply hijack on</span>
00114 <span class="comment"> * the master channel, hence avoiding the costly authentication step (and</span>
00115 <span class="comment"> * executing significantly faster). The only exception are the "COPY" </span>
00116 <span class="comment"> * routines, which can not hijack the master channel and hence must do</span>
00117 <span class="comment"> * authentication every time.</span>
00118 <span class="comment"> *</span>
00119 <span class="comment"> *      One more detail: some methods allow for interactive communication</span>
00120 <span class="comment"> * with the remote end. We have simply used a terminal-less connection</span>
00121 <span class="comment"> * for them, using regular files as the intermediate communication channels.</span>
00122 <span class="comment"> * A pipe implementation is also possible, and works as well, but we have</span>
00123 <span class="comment"> * found that dealing with pipes is tricky and error-prone, while using</span>
00124 <span class="comment"> * files is simple and intuitive, so we opted for using files.</span>
00125 <span class="comment"> *</span>
00126 <span class="comment"> *      The difference has to do with the way you communicate with the</span>
00127 <span class="comment"> * other end: using pipes you may block on read and/or write, and so</span>
00128 <span class="comment"> * may the other end. Since there may occur errors in the process, that</span>
00129 <span class="comment"> * implies that getting into a deadlock is trivial. Just picture this</span>
00130 <span class="comment"> * scenarios:</span>
00131 <span class="comment"> *</span>
00132 <span class="comment"> *      You send a command -&gt; the remote ends starts the command and</span>
00133 <span class="comment"> * prompts for input on stdout, hangs reding on stdin -&gt; you read the </span>
00134 <span class="comment"> * prompt and send the input -&gt; the remote end wakes and processes it.</span>
00135 <span class="comment"> *</span>
00136 <span class="comment"> *      You send a command -&gt; the remote end fails, logs an error on</span>
00137 <span class="comment"> * stderr, gets back the system prompt and hangs on reading stdin -&gt; you</span>
00138 <span class="comment"> * notice the prompt and read stderr... since you can't predict the </span>
00139 <span class="comment"> * length of the error message you must empty the pipe... and when doing it</span>
00140 <span class="comment"> * you hang after reading the last char... -&gt; deadlock</span>
00141 <span class="comment"> *</span>
00142 <span class="comment"> *      You send a command -&gt; the remote end fails, logs an error on stderr,</span>
00143 <span class="comment"> * gets back the system prompt and hangs on reading stdin -&gt; you don't read</span>
00144 <span class="comment"> * stderr to avoid hanging, so submit a new command... this goes on and on</span>
00145 <span class="comment"> * until the remote side's stderr buffer fills, then the remote side locks</span>
00146 <span class="comment"> * waiting for you to read stderr -&gt; you can't know it hang, so you try</span>
00147 <span class="comment"> * to submit a new command, and hang on writing waiting for the other end</span>
00148 <span class="comment"> * to read your command -&gt; deadlock</span>
00149 <span class="comment"> *</span>
00150 <span class="comment"> *      More scenarios are possible, and since you (or the other side)</span>
00151 <span class="comment"> * can't predict what's going to happen, it is very tricy to avoid them.</span>
00152 <span class="comment"> *</span>
00153 <span class="comment"> *      Now, using files, you don't have that problem: whenever you reach</span>
00154 <span class="comment"> * the current end-of-file, you get an EOF, no need to hang waiting for</span>
00155 <span class="comment"> * the other side to fill it in with data. The other side doesn't hang on</span>
00156 <span class="comment"> * writing unless your disk space fills up. It's a lot simpler. </span>
00157 <span class="comment"> *</span>
00158 <span class="comment"> *      Your problem with files is continuing reads after new data becomes</span>
00159 <span class="comment"> * available: the safest way is to call flush() before reading and seeking</span>
00160 <span class="comment"> * to the last position read to avoid having to re-read everything (which</span>
00161 <span class="comment"> * implies that after finishing reading you must ftell() your position.</span>
00162 <span class="comment"> *</span>
00163 <span class="comment"> *      See the included test script for examples.</span>
00164 <span class="comment"> *</span>
00165 <span class="comment"> * &lt;b&gt;CUSTOMIZATION&lt;/b&gt;</span>
00166 <span class="comment"> *</span>
00167 <span class="comment"> *      You &lt;i&gt;must&lt;/i&gt; state to the class where your SSH executables (ssh and</span>
00168 <span class="comment"> * scp) are located. This allows you to have them placed anywhere, but</span>
00169 <span class="comment"> * also implies the responsability of using full pathnames to reduce</span>
00170 <span class="comment"> * hacking dangers. It also allows you to use/test a new SSH implementation</span>
00171 <span class="comment"> * installed in a non-standard place before switching to it, or even to</span>
00172 <span class="comment"> * keep various SSH installations on the system (e.g. if the system's</span>
00173 <span class="comment"> * SSH is not up-to-date, you may install one on your home and use it).</span>
00174 <span class="comment"> *</span>
00175 <span class="comment"> *      You may also indicate where to store temporary files. This must </span>
00176 <span class="comment"> * be a directory followed by a prefix to use when creating a temporal</span>
00177 <span class="comment"> * directory. The parent directory must be writeable by the user who runs </span>
00178 <span class="comment"> * the class (usually it will be run by apache, www or some such). Most commonly </span>
00179 <span class="comment"> * the parent directory will be /tmp or $DocumentRoot/tmp or something similar.</span>
00180 <span class="comment"> *</span>
00181 <span class="comment"> *      The directory+prefix you state will be used to create a unique</span>
00182 <span class="comment"> * temporary work directory for each object instantiated. Examples of</span>
00183 <span class="comment"> * a valid specifications are "/tmp/phpSsh-" or "/tmp/". When the object is </span>
00184 <span class="comment"> * instantiated, a random string will be appended to this value to create</span>
00185 <span class="comment"> * the actual temporary directory name.</span>
00186 <span class="comment"> *      </span>
00187 <span class="comment"> *      The reason for allowing specifying a prefix is so that debugging</span>
00188 <span class="comment"> * may be easier by facilitating identification of temporaries generated</span>
00189 <span class="comment"> * by this class.</span>
00190 <span class="comment"> *</span>
00191 <span class="comment"> * &lt;b&gt;DEBUGGING&lt;/b&gt;</span>
00192 <span class="comment"> *</span>
00193 <span class="comment"> *      The class comes with extensive debugging aids. To enable them,</span>
00194 <span class="comment"> * just set a global variable called $debug to TRUE. This will output</span>
00195 <span class="comment"> * abundant debugging information and leave copies of communication log</span>
00196 <span class="comment"> * files for your reference.</span>
00197 <span class="comment"> *</span>
00198 <span class="comment"> *      Additionally, there is a sample demo script that shows how to</span>
00199 <span class="comment"> * use this class and may help you debug it. This script is included </span>
00200 <span class="comment"> * in the distribution (or should be) as 'ssh_debug.php'. See notes</span>
00201 <span class="comment"> * and comments within it for more details.</span>
00202 <span class="comment"> *</span>
00203 <span class="comment"> * @category    Net</span>
00204 <span class="comment"> * @package     SExec</span>
00205 <span class="comment"> * @author      José R. Valverde &lt;jrvalverde@acm.org&gt;</span>
00206 <span class="comment"> * @copyright   José R. Valverde &lt;jrvalverde@es.embnet.org&gt;</span>
00207 <span class="comment"> * @license     doc/lic/</span>
00208 <span class="comment"> * @version     Release: @package_version@</span>
00209 <span class="comment"> * @link        http://savannah.cern.ch/projects/GridGRAMM</span>
00210 <span class="comment"> * @see         ssh(1), scp(1)</span>
00211 <span class="comment"> * @since       File available since Release 1.0</span>
00212 <span class="comment"></span>
00213 <span class="comment"> */</span>
00214 <span class="keyword">class </span>SExec {
00215 
00216     <span class="comment">// {{{ properties</span>
00217 <span class="comment"></span>
00218 <span class="comment">    /**</span>
00219 <span class="comment">     * The current version of the class</span>
00220 <span class="comment">     *</span>
00221 <span class="comment">     * @var string</span>
00222 <span class="comment">     * @access public</span>
00223 <span class="comment">     */</span>
00224     var $version=<span class="stringliteral">"2.0"</span>;
00225     <span class="comment"></span>
00226 <span class="comment">    /**</span>
00227 <span class="comment">     * remote endpoint ([user@]host[:port])</span>
00228 <span class="comment">     *</span>
00229 <span class="comment">     * @var string</span>
00230 <span class="comment">     * @access private</span>
00231 <span class="comment">     */</span>
00232     var <a class="code" href="test-pers_8php.html#a1">$remote</a>;
00233     <span class="comment"></span>
00234 <span class="comment">    /**</span>
00235 <span class="comment">     * remote password </span>
00236 <span class="comment">     *</span>
00237 <span class="comment">     * @var string</span>
00238 <span class="comment">     * @access private</span>
00239 <span class="comment">     */</span>
00240     var <a class="code" href="test-pers_8php.html#a2">$password</a>;
00241 <span class="comment"></span>
00242 <span class="comment">    /**</span>
00243 <span class="comment">     * location of ssh program</span>
00244 <span class="comment">     *</span>
00245 <span class="comment">     * @var string</span>
00246 <span class="comment">     * @access private</span>
00247 <span class="comment">     */</span>
00248     var $ssh = <span class="stringliteral">"/usr/bin/ssh"</span>;
00249     <span class="comment"></span>
00250 <span class="comment">    /**</span>
00251 <span class="comment">     * location of scp program</span>
00252 <span class="comment">     *</span>
00253 <span class="comment">     * @var string</span>
00254 <span class="comment">     * @access private</span>
00255 <span class="comment">     */</span>
00256     var $scp = <span class="stringliteral">"/usr/bin/scp"</span>;
00257     <span class="comment"></span>
00258 <span class="comment">    /**</span>
00259 <span class="comment">     * tmp. dir prefix specification</span>
00260 <span class="comment">     *</span>
00261 <span class="comment">     * @var string</span>
00262 <span class="comment">     * @access private</span>
00263 <span class="comment">     */</span>
00264     var <a class="code" href="test-pers_8php.html#a3">$workdir</a> = <span class="stringliteral">"/tmp/phpSsh"</span>;
00265     <span class="comment"></span>
00266 <span class="comment">    /**</span>
00267 <span class="comment">     * name of multiplexing socket</span>
00268 <span class="comment">     *</span>
00269 <span class="comment">     * @var string</span>
00270 <span class="comment">     * @access private</span>
00271 <span class="comment">     */</span>
00272     var $mplex_socket = <span class="stringliteral">"/tmp/ssh.mplex"</span>;
00273     <span class="comment"></span>
00274 <span class="comment">    /**</span>
00275 <span class="comment">     * handle to process controlling the master channel</span>
00276 <span class="comment">     *</span>
00277 <span class="comment">     * @var string</span>
00278 <span class="comment">     * @access private</span>
00279 <span class="comment">     */</span>
00280     var $master;
00281     <span class="comment"></span>
00282 <span class="comment">    /**</span>
00283 <span class="comment">     * stdin of process controlling the master channel</span>
00284 <span class="comment">     *</span>
00285 <span class="comment">     * @var string</span>
00286 <span class="comment">     * @access private</span>
00287 <span class="comment">     */</span>
00288     var $master_input;
00289 
00290     <span class="comment">//}}}</span>
00291     
00292     <span class="comment">//{{{   instantiation</span>
00293     <span class="comment"></span>
00294 <span class="comment">    /** Class constructor.</span>
00295 <span class="comment">     *</span>
00296 <span class="comment">     *  Generate a new instance of a remote execution environment.</span>
00297 <span class="comment">     * The object returned allows you to invoke commands to be executed</span>
00298 <span class="comment">     * remotely in a way similar to PHP exec commands (popen, proc_open...)</span>
00299 <span class="comment">     * over SSH (so that your communications can be secure).</span>
00300 <span class="comment">     *</span>
00301 <span class="comment">     *  You may specify a remote endpoint and a password, a remote endpoint</span>
00302 <span class="comment">     * alone, or nothing at all.</span>
00303 <span class="comment">     *</span>
00304 <span class="comment">     *  If you provide a remote endpoint and password they are used to drive</span>
00305 <span class="comment">     * the communications and execute your commands.</span>
00306 <span class="comment">     *</span>
00307 <span class="comment">     *  If no password is provided, then a default of "xxyzzy" (the canonical</span>
00308 <span class="comment">     * computer magic word) is used. Unless this is your password (not </span>
00309 <span class="comment">     * recommended), this means that the default password is useless unless</span>
00310 <span class="comment">     * you are working in a trusted environment where it is not needed and</span>
00311 <span class="comment">     * ignored. That may be the case if you enable trusting mechanisms with</span>
00312 <span class="comment">     * .shosts/.rhosts or passphraseless RSA/DSA authentication. Not that</span>
00313 <span class="comment">     * we endorse them either, but in these cases any password provided will</span>
00314 <span class="comment">     * be ignored and it doesn't make sense to provide a real one: xxyzzy</span>
00315 <span class="comment">     * can do as well as any other.</span>
00316 <span class="comment">     *</span>
00317 <span class="comment">     *  If no password and no remote end is provided, then "localhost" is</span>
00318 <span class="comment">     * used as the remote end, assuming no password is required (as described</span>
00319 <span class="comment">     * above). This is only useful if localhost is trusted, and you have reasons</span>
00320 <span class="comment">     * to use SSH internally... Some people does.</span>
00321 <span class="comment">     *</span>
00322 <span class="comment">     *  Regarding the remote end specification, it can be any valid single-string</span>
00323 <span class="comment">     * SSH remote end description: the basic format is</span>
00324 <span class="comment">     *</span>
00325 <span class="comment">     *  [username@]remote.host[:port]</span>
00326 <span class="comment">     *</span>
00327 <span class="comment">     *  - "username" is the remote user name to log in as. It is optional. If provided, </span>
00328 <span class="comment">     *    it must be separated from the remote host by an "@" sign. If it is not </span>
00329 <span class="comment">     *    provided, the remote username is assumed to be the same as the current local</span>
00330 <span class="comment">     *    one.</span>
00331 <span class="comment">     *</span>
00332 <span class="comment">     *  - "remote.host" is a valid host specification, either a numeric IP address</span>
00333 <span class="comment">     *    or a valid host name (which may require a full name or not depending on</span>
00334 <span class="comment">     *    your settings).</span>
00335 <span class="comment">     *</span>
00336 <span class="comment">     *  - "port" is the remote port where SSH is listening and which we want to</span>
00337 <span class="comment">     *    connect to. It is optional, and if provided, must follow the remote host</span>
00338 <span class="comment">     *    specification separated from it by a colon ":". If not provided, the</span>
00339 <span class="comment">     *    default port (22) is used.</span>
00340 <span class="comment">     *</span>
00341 <span class="comment">     *  Examples of remote host specifications are "user@host.example.net:22",</span>
00342 <span class="comment">     * "someone@host:22", "host.example.net:22", "host:22", </span>
00343 <span class="comment">     * "somebody@host.example.net", "user@host", "host.example.net", "host".</span>
00344 <span class="comment">     *</span>
00345 <span class="comment">     * Here is an example of how to use this constructor:</span>
00346 <span class="comment">     * &lt;code&gt;</span>
00347 <span class="comment">     *  require_once 'ssh.php';</span>
00348 <span class="comment">     *</span>
00349 <span class="comment">     *  $remote = "jruser@example.com";</span>
00350 <span class="comment">     *  $password = "PASSWORD";</span>
00351 <span class="comment">     *</span>
00352 <span class="comment">     *  $rmt = new SExec($remote, $password);</span>
00353 <span class="comment">     *   if (! $rmt)</span>
00354 <span class="comment">     *          echo "Couldn't connect to $remote\n";</span>
00355 <span class="comment">     * &lt;/code&gt;</span>
00356 <span class="comment">     *</span>
00357 <span class="comment">     *  @param string remote   The remote end to run the command, in</span>
00358 <span class="comment">     *                      the form 'user@host:port' (you may</span>
00359 <span class="comment">     *                      omit the 'user@' or ':port' parts</span>
00360 <span class="comment">     *                      if the default values [i.e. same user</span>
00361 <span class="comment">     *                      or standard port] are OK).</span>
00362 <span class="comment">     *</span>
00363 <span class="comment">     *  @param string password The remote password. Note that if direct</span>
00364 <span class="comment">     *                      RSA/DSA/.shosts/.rhosts login is enabled</span>
00365 <span class="comment">     *                      then the password will be ignored as</span>
00366 <span class="comment">     *                      SSH should not run the ASKPASS command).</span>
00367 <span class="comment">     *</span>
00368 <span class="comment">     *  @return SExec|false a new connection object with the remote end or</span>
00369 <span class="comment">     *                      FALSE if the connection could not be established.</span>
00370 <span class="comment">     *</span>
00371 <span class="comment">     *  @access public</span>
00372 <span class="comment">     *  @since Method available since Release 1.0</span>
00373 <span class="comment">     */</span>
00374     function <a class="code" href="classSExec.html">SExec</a>($remote=<span class="stringliteral">"localhost"</span>, $password=<span class="stringliteral">"xxyzzy"</span>)
00375     {
00376         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
00377         
00378         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"\nCreating a new SExec\n"</span>;
00379         $this-&gt;remote = <a class="code" href="test-pers_8php.html#a1">$remote</a>;
00380         $this-&gt;password = <span class="stringliteral">"$password"</span>;
00381         umask(0077);
00382         <span class="comment">/* DESIGN</span>
00383 <span class="comment">         * In order to increase efficiency, we will create a master channel</span>
00384 <span class="comment">         * on class instantiation. The master channel should be closed by a</span>
00385 <span class="comment">         * corresponding class destructor!</span>
00386 <span class="comment">         *</span>
00387 <span class="comment">         * Creating a master channel has the advantage that subsequent SSH</span>
00388 <span class="comment">         * connections will use it and avoid repeating the slow authentication</span>
00389 <span class="comment">         * process: in other words, they will go much, much faster.</span>
00390 <span class="comment">         */</span>
00391          
00392         <span class="comment">// first we must generate a unique UNIX socket address or we'll fail</span>
00393         <span class="comment">// We use a tricky trick: generate two random numbers and use them;</span>
00394         <span class="comment">// this is tricky since there might be a problem, but with very low</span>
00395         <span class="comment">// probability. BUT IT MAY STILL FAIL: there's a race condition between</span>
00396         <span class="comment">// the end of the while and the subsequent if.</span>
00397         <span class="keywordflow">do</span> {
00398             mt_srand((<span class="keywordtype">double</span>)microtime()*1000000 ) .
00399             $this-&gt;workdir = <span class="stringliteral">"/tmp/phpSsh-"</span> . mt_rand() .<span class="stringliteral">"."</span>. mt_rand();
00400             <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"\nSExec: trying $this-&gt;workdir/ ..."</span>;
00401             <span class="comment">// CAUTION: this is potentially an endless loop (albeit with very</span>
00402             <span class="comment">// low probability) if every possible file did exist.</span>
00403         }
00404         <span class="keywordflow">while</span> (file_exists($this-&gt;workdir));
00405         <span class="keywordflow">if</span> (mkdir($this-&gt;workdir) == FALSE) {
00406             <span class="comment">// we can't continue. How can we cancel this?</span>
00407             <span class="comment">// try these and then check what happens</span>
00408             unset($<span class="keyword">this</span>);
00409             $this = NULL;
00410             <span class="keywordflow">return</span> FALSE;
00411         }
00412         <span class="keywordflow">else</span> 
00413             <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">" OK\n"</span>;
00414         <span class="comment">// Now we have a place to put the socket... Mmm...</span>
00415         <span class="comment">// Come to think of it, we have a place to put ANY temporary</span>
00416         <span class="comment">// for the class... </span>
00417         <span class="comment">// XXX Maybe we can change everywhere else to use this?</span>
00418         $this-&gt;mplex_socket = $this-&gt;workdir.<span class="stringliteral">"/mplex_socket"</span>;
00419         
00420         <span class="comment">// Finally we can call SSH -M</span>
00421         <span class="comment">// Create SSH_ASKPASS script to provide the password</span>
00422         <a class="code" href="test-pers_8php.html#a4">$tmpfname</a> = tempnam($this-&gt;workdir, 'SExec-');
00423         chmod($tmpfname, 0700);
00424         putenv(<span class="stringliteral">"DISPLAY=none:0."</span>);
00425         putenv(<span class="stringliteral">"SSH_ASKPASS=$tmpfname"</span>);
00426         <a class="code" href="test-pers_8php.html#a5">$fp</a> = fopen($tmpfname, <span class="stringliteral">"w"</span>);
00427         fputs($fp, <span class="stringliteral">"#!/bin/sh\necho $this-&gt;password\n"</span>);
00428         <span class="keywordflow">if</span> (!<a class="code" href="ssh__test_8php.html#a0">$debug</a>) 
00429             fputs($fp, <span class="stringliteral">"/bin/touch $tmpfname.called\n"</span>);
00430         <span class="keywordflow">else</span>
00431             fputs($fp, <span class="stringliteral">"/bin/rm -f $tmpfname\n"</span>);
00432         fclose($fp);
00433         
00434         <span class="comment">// OK, we are ready. Now let's open a master shell</span>
00435         <a class="code" href="test-pers_8php.html#a6">$child_stdout</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-O-"</span>);
00436         <a class="code" href="test-pers_8php.html#a7">$child_stderr</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-E-"</span>);
00437         <a class="code" href="test-pers_8php.html#a8">$descriptorspec</a> = array(
00438             0 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"r"</span>),  <span class="comment">// connect child's stdin to the read end of a pipe</span>
00439             1 =&gt; array(<span class="stringliteral">"file"</span>, $child_stdout, <span class="stringliteral">"a"</span>),  <span class="comment">// connect child's stdout to the write end of a pipe</span>
00440             2 =&gt; array(<span class="stringliteral">"file"</span>, $child_stderr, <span class="stringliteral">"a"</span>)   <span class="comment">// stderr is a pipe to read from</span>
00441         );
00442 
00443         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"$this-&gt;ssh -x -t -t "</span>.
00444                      <span class="stringliteral">"-M -S $this-&gt;mplex_socket "</span> .
00445                      <span class="stringliteral">"$this-&gt;remote\n"</span>;
00446         $this-&gt;master = proc_open(<span class="stringliteral">"$this-&gt;ssh -x -t -t "</span>.
00447                      <span class="stringliteral">"-M -S $this-&gt;mplex_socket "</span> .
00448                      <span class="stringliteral">"$this-&gt;remote"</span>,
00449                      $descriptorspec,
00450                      $pipes);
00451         <span class="keywordflow">if</span> ((! is_resource($this-&gt;master)) || ($this-&gt;master == FALSE)) {
00452                 putenv(<span class="stringliteral">"SSH_ASKPASS=dummy"</span>);
00453                 unset($<span class="keyword">this</span>);
00454                 $this = NULL;
00455                 <span class="keywordflow">return</span> FALSE;
00456         }
00457         <span class="comment">// we do not need to worry about the output log files, just the</span>
00458         <span class="comment">// input pipe for logout</span>
00459         $this-&gt;master_input = $pipes[0];
00460         
00461         <span class="comment">// Before going ahead, we need to ensure the control shell </span>
00462         <span class="comment">// has started: wait for the socket to become available</span>
00463         <span class="comment">// note: there should be a timeout here to avoid a possibly</span>
00464         <span class="comment">// infinite loop XXX</span>
00465         <span class="keywordflow">do</span> {
00466             <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"waiting 0.1 sec\n"</span>;
00467             usleep(100000);     <span class="comment">// wait 0.1 seconds</span>
00468         } <span class="keywordflow">while</span> (! file_exists($this-&gt;mplex_socket));
00469 
00470         <span class="comment">// and now we must register a destructor for the class</span>
00471         <span class="comment">// that will close the connection.</span>
00472         <span class="comment">//register_shutdown_function($this-&gt;destruct());</span>
00473         
00474         <span class="keywordflow">return</span> $this;
00475     }
00476     <span class="comment"></span>
00477 <span class="comment">    /** Class destructor</span>
00478 <span class="comment">     *</span>
00479 <span class="comment">     *  Destroy all working processes and data streams and structures</span>
00480 <span class="comment">     * used by an instance of this class.</span>
00481 <span class="comment">     *</span>
00482 <span class="comment">     *  This method will send a termination message to the other end</span>
00483 <span class="comment">     * of the master channel, close the control stream of the master</span>
00484 <span class="comment">     * channel and terminate its controlling process, finally unsetting</span>
00485 <span class="comment">     * the object and setting the object handle to NULL.</span>
00486 <span class="comment">     *</span>
00487 <span class="comment">     *  If a global $debug is not set to TRUE, then it will also remove</span>
00488 <span class="comment">     * all communication traces of this object: i.e. all log files for</span>
00489 <span class="comment">     * interactive and master sessions, communications socket, etc...</span>
00490 <span class="comment">     *</span>
00491 <span class="comment">     *  If global $debug is set to TRUE, then a copy of all log files</span>
00492 <span class="comment">     * created during the lifetime of the object will be left on a</span>
00493 <span class="comment">     * temporary directory for your perusal and reference.</span>
00494 <span class="comment">     *</span>
00495 <span class="comment">     *  @return integer exit status of the master channel control process.</span>
00496 <span class="comment">     *</span>
00497 <span class="comment">     *  @access public</span>
00498 <span class="comment">     *  @since Method available since Release 1.0</span>
00499 <span class="comment">     */</span>
00500     function destruct()
00501     {
00502         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
00503         
00504         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"\nDestroying SExec master\n"</span>;
00505         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) print_r($<span class="keyword">this</span>);
00506         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"sending logout\n"</span>;
00507         <span class="comment">// log out master process</span>
00508         fputs($this-&gt;master_input, <span class="stringliteral">"\n\nlogout\n\n"</span>);
00509         <span class="comment">// close master stdin</span>
00510         fclose($this-&gt;master_input);
00511         <span class="comment">// close master process</span>
00512         $ret = proc_close($this-&gt;master);
00513         <span class="comment">// remove temporaries</span>
00514         <span class="keywordflow">if</span> (! <a class="code" href="ssh__test_8php.html#a0">$debug</a>) system(<span class="stringliteral">"/bin/rm -rf $this-&gt;workdir"</span>);
00515         <span class="comment">// utterly destroy this instance</span>
00516         unset($<span class="keyword">this</span>);
00517         $this = NULL;
00518         <span class="keywordflow">return</span> $ret;
00519     }    
00520     
00521     <span class="comment">//}}}</span>
00522     
00523     <span class="comment">//{{{ methods</span><span class="comment"></span>
00524 <span class="comment">    /**</span>
00525 <span class="comment">     *  Copy a file or directory from one source to a destination</span>
00526 <span class="comment">     *</span>
00527 <span class="comment">     *  This function copies source to dest, where one of them is a</span>
00528 <span class="comment">     * local filespec and the other a remote filespec of the form</span>
00529 <span class="comment">     * [user@]host:path</span>
00530 <span class="comment">     *</span>
00531 <span class="comment">     *  If the original source is a directory, it will be copied</span>
00532 <span class="comment">     * recursively to destination (hence easing file transfers).</span>
00533 <span class="comment">     *</span>
00534 <span class="comment">     *  The function returns TRUE on success or FALSE on failure.</span>
00535 <span class="comment">     *</span>
00536 <span class="comment">     * &lt;b&gt;EFFICIENCY NOTICE:&lt;/b&gt;</span>
00537 <span class="comment">     *</span>
00538 <span class="comment">     *  The copy routines use 'scp' to do their actual work. Since</span>
00539 <span class="comment">     * scp seems to be unable to hitchhike on the master channel,</span>
00540 <span class="comment">     * we must do authentication for each copy operation (subroutine </span>
00541 <span class="comment">     * call). These routines are hence a lot more time-expensive </span>
00542 <span class="comment">     * than all the other ones.</span>
00543 <span class="comment">     *</span>
00544 <span class="comment">     *  You may want to consider whether you can group several</span>
00545 <span class="comment">     * copies into one single call to reduce authentication </span>
00546 <span class="comment">     * overheads.</span>
00547 <span class="comment">     *</span>
00548 <span class="comment">     *  @note DEPRECATED (inconsistent with the class)</span>
00549 <span class="comment">     *</span>
00550 <span class="comment">     *  @see scp(1)</span>
00551 <span class="comment">     *</span>
00552 <span class="comment">     *  @param string origin    The origin path, of the form</span>
00553 <span class="comment">     *                  [user@][host][:port]path</span>
00554 <span class="comment">     *                  You may omit the optional sections if</span>
00555 <span class="comment">     *                  the default values (local username, local</span>
00556 <span class="comment">     *                  host, standard SSH port) are OK</span>
00557 <span class="comment">     *</span>
00558 <span class="comment">     *  @param string destination       The destination path, of the form</span>
00559 <span class="comment">     *                  [user@][host][:port:]path</span>
00560 <span class="comment">     *                  You may omit the optional sections if</span>
00561 <span class="comment">     *                  the default values (local username, local</span>
00562 <span class="comment">     *                  host, standard SSH port) are OK</span>
00563 <span class="comment">     *</span>
00564 <span class="comment">     *  @param string password  The password to use to connect to the remote</span>
00565 <span class="comment">     *                  end of the copy (be it the origin or the</span>
00566 <span class="comment">     *                  destination, it's all the same). If connection</span>
00567 <span class="comment">     *                  is automatic by some means (.shosts or RSA/DSA</span>
00568 <span class="comment">     *                  authentication) then it should be ignored and</span>
00569 <span class="comment">     *                  any password should do.</span>
00570 <span class="comment">     *</span>
00571 <span class="comment">     *  @return bool TRUE if all went well, or FALSE on failure.</span>
00572 <span class="comment">     *</span>
00573 <span class="comment">     *  @access public</span>
00574 <span class="comment">     *  @since Method available since Release 1.0</span>
00575 <span class="comment">     *  @deprecated Method deprecated as of Release 2.1</span>
00576 <span class="comment">     */</span>
00577     function <a class="code" href="util_8php.html#a6">ssh_copy</a>($origin, $destination, $password)
00578     {
00579         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
00580 
00581         umask(0077);
00582         <a class="code" href="test-pers_8php.html#a4">$tmpfname</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"copy-"</span>);
00583         chmod($tmpfname, 0700);
00584         putenv(<span class="stringliteral">"DISPLAY=none:0."</span>);
00585         putenv(<span class="stringliteral">"SSH_ASKPASS=$tmpfname"</span>);
00586         <a class="code" href="test-pers_8php.html#a5">$fp</a> = fopen($tmpfname, <span class="stringliteral">"w"</span>);
00587         fputs($fp, <span class="stringliteral">"#!/bin/sh\necho $password\n"</span>);
00588         <span class="keywordflow">if</span> (! <a class="code" href="ssh__test_8php.html#a0">$debug</a>)  
00589             fputs($fp, <span class="stringliteral">"/bin/touch $tmpfname.called\n"</span>);
00590         <span class="keywordflow">else</span>
00591             fputs($fp, <span class="stringliteral">"/bin/rm $tmpfname\n"</span>);
00592         fclose($fp);
00593         exec(<span class="stringliteral">"$this-&gt;scp -pqrC $origin $destination"</span>, $out, $status);
00594         <span class="keywordflow">if</span> ($status == 0)
00595             <span class="keywordflow">return</span> TRUE;
00596         <span class="keywordflow">else</span>
00597             <span class="keywordflow">return</span> FALSE;
00598     }
00599 
00600 <span class="comment"></span>
00601 <span class="comment">    /**</span>
00602 <span class="comment">     *  Copy a file or directory from a local source to a remote destination</span>
00603 <span class="comment">     *</span>
00604 <span class="comment">     *  This function copies source to dest, where first of them is a</span>
00605 <span class="comment">     * local filespec and then comes a remote filespec as a normal</span>
00606 <span class="comment">     * system path.</span>
00607 <span class="comment">     *</span>
00608 <span class="comment">     *  Both, local and remote paths may be absolute or relative.</span>
00609 <span class="comment">     *</span>
00610 <span class="comment">     *  If the original source is a directory, it will be copied</span>
00611 <span class="comment">     * recursively to destination (hence easing file transfers).</span>
00612 <span class="comment">     *</span>
00613 <span class="comment">     *  The function returns TRUE on success or FALSE on failure.</span>
00614 <span class="comment">     *</span>
00615 <span class="comment">     * &lt;b&gt;EFFICIENCY NOTICE:&lt;/b&gt;</span>
00616 <span class="comment">     *</span>
00617 <span class="comment">     *  The copy routines use 'scp' to do their actual work. Since</span>
00618 <span class="comment">     * scp seems to be unable to hitchhike on the master channel,</span>
00619 <span class="comment">     * we must do authetication for each copy operation (subroutine </span>
00620 <span class="comment">     * call). These routines are hence a lot more time-expensive </span>
00621 <span class="comment">     * than all the other ones.</span>
00622 <span class="comment">     *</span>
00623 <span class="comment">     *  You may want to consider whether you can group several</span>
00624 <span class="comment">     * copies into one single call to reduce authentication </span>
00625 <span class="comment">     * overheads.</span>
00626 <span class="comment">     *</span>
00627 <span class="comment">     *  @see scp(1)</span>
00628 <span class="comment">     *</span>
00629 <span class="comment">     *  @param string localpath    The origin local path, either absolute or</span>
00630 <span class="comment">     *                  relative to the current working directory. </span>
00631 <span class="comment">     *                  If it denotes a directory, the copy will </span>
00632 <span class="comment">     *                  be recursive.</span>
00633 <span class="comment">     *</span>
00634 <span class="comment">     *  @param string remotepath   The destination path, either</span>
00635 <span class="comment">     *                  absolute or relative to the login home.</span>
00636 <span class="comment">     *</span>
00637 <span class="comment">     *  @return bool TRUE if all went well, or FALSE on failure.</span>
00638 <span class="comment">     *</span>
00639 <span class="comment">     *  @access public</span>
00640 <span class="comment">     *  @since Method available since Release 2.1</span>
00641 <span class="comment">     */</span>
00642     function ssh_copy_to($localpath, $remotepath)
00643     {
00644         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
00645 
00646         umask(0077);
00647         <a class="code" href="test-pers_8php.html#a4">$tmpfname</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"copy-to-"</span>);
00648         chmod($tmpfname, 0700);
00649         putenv(<span class="stringliteral">"DISPLAY=none:0."</span>);
00650         putenv(<span class="stringliteral">"SSH_ASKPASS=$tmpfname"</span>);
00651         <a class="code" href="test-pers_8php.html#a5">$fp</a> = fopen($tmpfname, <span class="stringliteral">"w"</span>);
00652         fputs($fp, <span class="stringliteral">"#!/bin/sh\necho $this-&gt;password\n"</span>);
00653         <span class="keywordflow">if</span> (! <a class="code" href="ssh__test_8php.html#a0">$debug</a>)  
00654             fputs($fp, <span class="stringliteral">"/bin/touch $tmpfname.called\n"</span>);
00655         <span class="keywordflow">else</span>
00656             fputs($fp, <span class="stringliteral">"/bin/rm $tmpfname\n"</span>);
00657         fclose($fp);
00658         exec(<span class="stringliteral">"$this-&gt;scp -pqrC $localpath $this-&gt;remote:$remotepath"</span>, $out, $status);
00659         <span class="keywordflow">if</span> ($status == 0)
00660             <span class="keywordflow">return</span> TRUE;
00661         <span class="keywordflow">else</span>
00662             <span class="keywordflow">return</span> FALSE;
00663     }
00664     <span class="comment"></span>
00665 <span class="comment">    /**</span>
00666 <span class="comment">     *  Copy a file or directory from a remote source to a local destination</span>
00667 <span class="comment">     *</span>
00668 <span class="comment">     *  This function copies source to dest, where first of them is a</span>
00669 <span class="comment">     * remote filespec and then comes a local filespec, both specified </span>
00670 <span class="comment">     * as normal system paths.</span>
00671 <span class="comment">     *</span>
00672 <span class="comment">     *  Both, local and remote paths may be absolute or relative.</span>
00673 <span class="comment">     *</span>
00674 <span class="comment">     *  If the original source is a directory, it will be copied</span>
00675 <span class="comment">     * recursively to destination (hence easing file transfers).</span>
00676 <span class="comment">     *</span>
00677 <span class="comment">     *  The function returns TRUE on success or FALSE on failure.</span>
00678 <span class="comment">     *</span>
00679 <span class="comment">     * EFFICIENCY NOTICE:</span>
00680 <span class="comment">     *</span>
00681 <span class="comment">     *  The copy routines use 'scp' to do their actual work. Since</span>
00682 <span class="comment">     * scp seems to be unable to hitchhike on the master channel,</span>
00683 <span class="comment">     * we must do authetication for each copy operation (subroutine </span>
00684 <span class="comment">     * call). These routines are hence a lot more time-expensive </span>
00685 <span class="comment">     * than all the other ones.</span>
00686 <span class="comment">     *</span>
00687 <span class="comment">     *  You may want to consider whether you can group several</span>
00688 <span class="comment">     * copies into one single call to reduce authentication </span>
00689 <span class="comment">     * overheads.</span>
00690 <span class="comment">     *</span>
00691 <span class="comment">     *  @see scp(1)</span>
00692 <span class="comment">     *</span>
00693 <span class="comment">     *  @param string remotepath   The origin remote path, either absolute or</span>
00694 <span class="comment">     *                  relative to the login home. If it denotes a </span>
00695 <span class="comment">     *                  directory, the copy will be recursive.</span>
00696 <span class="comment">     *</span>
00697 <span class="comment">     *  @param string localpath    The local destination path, either</span>
00698 <span class="comment">     *                  absolute or relative to the current working</span>
00699 <span class="comment">     *                  directory.</span>
00700 <span class="comment">     *</span>
00701 <span class="comment">     *  @return bool TRUE if all went well, or FALSE on failure.</span>
00702 <span class="comment">     *</span>
00703 <span class="comment">     *  @access public</span>
00704 <span class="comment">     *  @since Method available since Release 1.0</span>
00705 <span class="comment">     */</span>
00706     function ssh_copy_from($remotepath, $localpath)
00707     {
00708         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
00709 
00710         umask(0077);
00711         <a class="code" href="test-pers_8php.html#a4">$tmpfname</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"copy-from-"</span>);
00712         chmod($tmpfname, 0700);
00713         putenv(<span class="stringliteral">"DISPLAY=none:0."</span>);
00714         putenv(<span class="stringliteral">"SSH_ASKPASS=$tmpfname"</span>);
00715         <a class="code" href="test-pers_8php.html#a5">$fp</a> = fopen($tmpfname, <span class="stringliteral">"w"</span>);
00716         fputs($fp, <span class="stringliteral">"#!/bin/sh\necho $this-&gt;password\n"</span>);
00717         <span class="keywordflow">if</span> (! <a class="code" href="ssh__test_8php.html#a0">$debug</a>)  
00718             fputs($fp, <span class="stringliteral">"/bin/touch $tmpfname.called\n"</span>);
00719         <span class="keywordflow">else</span>
00720             fputs($fp, <span class="stringliteral">"/bin/rm $tmpfname\n"</span>);
00721         fclose($fp);
00722         exec(<span class="stringliteral">"$this-&gt;scp -pqrC $this-&gt;remote:$remotepath $localpath"</span>, $out, $status);
00723         <span class="keywordflow">if</span> ($status == 0)
00724             <span class="keywordflow">return</span> TRUE;
00725         <span class="keywordflow">else</span>
00726             <span class="keywordflow">return</span> FALSE;
00727     }
00728 <span class="comment"></span>
00729 <span class="comment">    /**</span>
00730 <span class="comment">     *  Execute a single command remotely</span>
00731 <span class="comment">     *</span>
00732 <span class="comment">     *  Execute a single command remotely using ssh and </span>
00733 <span class="comment">     * display its output, optionally returning its exit </span>
00734 <span class="comment">     * status (like passthru)</span>
00735 <span class="comment">     *</span>
00736 <span class="comment">     *  This function is intended to be used as a one-time</span>
00737 <span class="comment">     * all-at-once non-interactive execution mechanism which</span>
00738 <span class="comment">     * will run the command remotely and display its output.</span>
00739 <span class="comment">     *</span>
00740 <span class="comment">     *  If you try to issue an interactive command using this</span>
00741 <span class="comment">     * function, all you will get is unneccessary trouble. So</span>
00742 <span class="comment">     * don't!</span>
00743 <span class="comment">     *</span>
00744 <span class="comment">     *  This might be done as well using a pipe on /tmp and</span>
00745 <span class="comment">     * making the command 'cat' the pipe: when ssh runs, it</span>
00746 <span class="comment">     * runs the command 'cat' on the pipe and hangs on read.</span>
00747 <span class="comment">     *  Then we just need a thread to open the pipe, put the</span>
00748 <span class="comment">     * password and close the pipe.</span>
00749 <span class="comment">     *</span>
00750 <span class="comment">     *  This other way the password is never wirtten down.</span>
00751 <span class="comment">     * But, OTOH, the file life is so ephemeral that most</span>
00752 <span class="comment">     * of the time it will only exist in the internal system</span>
00753 <span class="comment">     * cache, so this approach is not that bad either.</span>
00754 <span class="comment">     *</span>
00755 <span class="comment">     *  @see passthru()</span>
00756 <span class="comment">     *</span>
00757 <span class="comment">     *  @param string command  The command to execute on the remote end</span>
00758 <span class="comment">     *                      NOTE: if you want to use redirection, the</span>
00759 <span class="comment">     *                      entire remote command line should be </span>
00760 <span class="comment">     *                      enclosed in additional quotes!</span>
00761 <span class="comment">     *  @param integer status   Optional, this will hold the termination</span>
00762 <span class="comment">     *                      status of SSH after invocation, which</span>
00763 <span class="comment">     *                      should be the exit status of the remote</span>
00764 <span class="comment">     *                      command or 255 if an error occurred</span>
00765 <span class="comment">     *  @return void</span>
00766 <span class="comment">     *</span>
00767 <span class="comment">     *  @access public</span>
00768 <span class="comment">     *  @since Method available since Release 1.0</span>
00769 <span class="comment">     */</span>
00770     function <a class="code" href="util_8php.html#a5">ssh_passthru</a>($command, &amp;$status)
00771     {
00772         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
00773 
00774         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"status = $status\n"</span>;
00775         <span class="comment">// go</span>
00776         <span class="keywordflow">if</span> (isset($status)) {
00777             <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"st: $this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\"\n"</span>;
00778             passthru(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>, $status);
00779         }
00780         <span class="keywordflow">else</span> {
00781             <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"~st: $this-&gt;ssh -x -t -t  -S $this-&gt;mplex_socket $this-&gt;remote \"$command\"\n"</span>;
00782             passthru(<span class="stringliteral">"$this-&gt;ssh -x -t -t  -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>);
00783         }
00784     }
00785     
00786     <span class="comment"></span>
00787 <span class="comment">    /**</span>
00788 <span class="comment">     *  Execute a remote command using SSH</span>
00789 <span class="comment">     *</span>
00790 <span class="comment">     *  This function sort of mimics rexec(3) using SSH as the transport</span>
00791 <span class="comment">     * protocol.</span>
00792 <span class="comment">     *</span>
00793 <span class="comment">     *  The function returns the exit status of the remote command, and</span>
00794 <span class="comment">     * appends the remote job output to an optional argument.</span>
00795 <span class="comment">     *</span>
00796 <span class="comment">     *  This function is intended to be used as a one-time</span>
00797 <span class="comment">     * all-at-once non-interactive execution mechanism which</span>
00798 <span class="comment">     * will run the command remotely and return its output.</span>
00799 <span class="comment">     *</span>
00800 <span class="comment">     *  If you try to issue an interactive command using this</span>
00801 <span class="comment">     * function, all you will get is unneccessary trouble. So</span>
00802 <span class="comment">     * don't!</span>
00803 <span class="comment">     *</span>
00804 <span class="comment">     *  @param string command  The command to execute on the remote end</span>
00805 <span class="comment">     *                      NOTE: if you want to use redirection, the</span>
00806 <span class="comment">     *                      entire remote command line should be </span>
00807 <span class="comment">     *                      enclosed in additional quotes!</span>
00808 <span class="comment">     *  @param string output   Optional, the collated (stdout+stderr) output </span>
00809 <span class="comment">     *                      of the remote command.</span>
00810 <span class="comment">     *  @return integer status  will hold the termination</span>
00811 <span class="comment">     *                      status of SSH after invocation, which</span>
00812 <span class="comment">     *                      should be the exit status of the remote</span>
00813 <span class="comment">     *                      command or 255 if an error occurred</span>
00814 <span class="comment">     *</span>
00815 <span class="comment">     *  @access public</span>
00816 <span class="comment">     *  @since Method available since Release 1.0</span>
00817 <span class="comment">     */</span>
00818     function ssh_exec($command, &amp;$out)
00819     {
00820         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
00821 
00822         umask(0077);
00823         <a class="code" href="test-pers_8php.html#a4">$tmpfname</a> = tempnam($this-&gt;workdir, 'exec');
00824         chmod($tmpfname, 0700);
00825         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <a class="code" href="test-pers_8php.html#a4">$tmpfname</a> . <span class="stringliteral">"\n"</span>;
00826 
00827         exec(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>, $out, $retval);
00828         <span class="keywordflow">return</span> $retval;
00829 
00830     }
00831     <span class="comment"></span>
00832 <span class="comment">    /**</span>
00833 <span class="comment">     *  Open an SSH connection to a remote site with a shell to run </span>
00834 <span class="comment">     * interactive commands</span>
00835 <span class="comment">     *</span>
00836 <span class="comment">     *  Connects to a remote host and opens an interactive shell session</span>
00837 <span class="comment">     * with NO controlling terminal.</span>
00838 <span class="comment">     *</span>
00839 <span class="comment">     *  This routine creates communication streams with the remote shell,</span>
00840 <span class="comment">     * and stores all output (standard and error) of the connection into</span>
00841 <span class="comment">     * two separate local log files (one for stdout and one for stderr).</span>
00842 <span class="comment">     *</span>
00843 <span class="comment">     *  Returns a process_control array which contains the process resource</span>
00844 <span class="comment">     * ID and an the standard file descriptors which the caller may use to</span>
00845 <span class="comment">     * interact with the remote shell.</span>
00846 <span class="comment">     *</span>
00847 <span class="comment">     * The process control array contains:</span>
00848 <span class="comment">     *</span>
00849 <span class="comment">     *  'process' -- the process resource for the newly created connection</span>
00850 <span class="comment">     *</span>
00851 <span class="comment">     *  'std_in' -- handle to the standard input of the new connection</span>
00852 <span class="comment">     *</span>
00853 <span class="comment">     *  'std_out' -- handle to standard output of the new connection</span>
00854 <span class="comment">     *</span>
00855 <span class="comment">     *  'std_err' -- handle to standard error of the new connection</span>
00856 <span class="comment">     *</span>
00857 <span class="comment">     *  'stdout_file' -- actual filename of the local log file for the</span>
00858 <span class="comment">     *          new connection standard output</span>
00859 <span class="comment">     *</span>
00860 <span class="comment">     *  'stderr_file' -- actual filename of the local log file for the</span>
00861 <span class="comment">     *          new connection standard error</span>
00862 <span class="comment">     *</span>
00863 <span class="comment">     *  @return mixed a process control associative array.</span>
00864 <span class="comment">     *</span>
00865 <span class="comment">     *  @access public</span>
00866 <span class="comment">     *  @since Method available since Release 1.0</span>
00867 <span class="comment">     */</span>
00868     function ssh_open_shell()
00869     {   
00870         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
00871 
00872         <span class="comment">// Open a child process with the 'proc_open' function. </span>
00873         <span class="comment">//</span>
00874         <span class="comment">// Some tricks: we must open the connection using '-x' to disable</span>
00875         <span class="comment">// X11 forwarding, and use '-t -t' to avoid SSH generating an error</span>
00876         <span class="comment">// because we are not connected to any terminal.</span>
00877         <span class="comment">//</span>
00878         <span class="comment">// NOTE: if the web server is trusted remotely (i.e. it's SSH public </span>
00879         <span class="comment">// key is accepted in ~user@host:.ssh/authorized_keys) then any </span>
00880         <span class="comment">// password will do.</span>
00881 
00882         <span class="comment">// Prepare I/O</span>
00883         umask(0077);
00884         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) {
00885             <a class="code" href="test-pers_8php.html#a6">$child_stdout</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-"</span>.getmypid().<span class="stringliteral">"-O-"</span>);
00886             <a class="code" href="test-pers_8php.html#a7">$child_stderr</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-"</span>.getmypid().<span class="stringliteral">"-E-"</span>);
00887         } <span class="keywordflow">else</span> {
00888             <a class="code" href="test-pers_8php.html#a6">$child_stdout</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-"</span>);
00889             <a class="code" href="test-pers_8php.html#a7">$child_stderr</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_sh-"</span>);
00890         }
00891         <a class="code" href="test-pers_8php.html#a8">$descriptorspec</a> = array(
00892             0 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"r"</span>),  <span class="comment">// connect child's stdin to the read end of a pipe</span>
00893             1 =&gt; array(<span class="stringliteral">"file"</span>, $child_stdout, <span class="stringliteral">"a"</span>),  <span class="comment">// connect child's stdout to the write end of a pipe</span>
00894             2 =&gt; array(<span class="stringliteral">"file"</span>, $child_stderr, <span class="stringliteral">"a"</span>)   <span class="comment">// stderr is a pipe to read from</span>
00895         );
00896         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote&lt;br /&gt;\n"</span>;
00897         <a class="code" href="test-pers_8php.html#a9">$process</a> = proc_open(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote"</span>, 
00898                          $descriptorspec,
00899                          $pipes);
00900         
00901         <span class="comment">// check status</span>
00902         <span class="keywordflow">if</span> (!is_resource($process)) 
00903         {
00904             <a class="code" href="util_8php.html#a4">letal</a>(<span class="stringliteral">"SSH::connect"</span>, <span class="stringliteral">"cannot connect to the remote host"</span>);
00905             <span class="keywordflow">return</span>;
00906         }
00907         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"proc_open done&lt;br /&gt;\n"</span>;
00908 
00909         <span class="comment">// $pipes now looks like this:</span>
00910         <span class="comment">//   0 =&gt; writeable handle connected to child stdin</span>
00911         
00912         <span class="comment">// Open child's stdin and stdout</span>
00913         $pipes[1] = fopen($child_stdout, <span class="stringliteral">"r"</span>);
00914         $pipes[2] = fopen($child_stderr, <span class="stringliteral">"r"</span>);
00915         
00916         <span class="comment">// Should we leave this to the user?</span>
00917         <span class="comment">// set to non-blocking and avoid having to call fflush</span>
00918         <span class="comment">//stream_set_blocking($pipes[0], FALSE);</span>
00919         <span class="comment">//stream_set_blocking($pipes[1], FALSE);</span>
00920         <span class="comment">//stream_set_blocking($pipes[2], FALSE);</span>
00921         stream_set_write_buffer($pipes[0], 0);
00922         stream_set_write_buffer($pipes[1], 0);
00923         stream_set_write_buffer($pipes[2], 0);
00924 
00925         <span class="comment">// We now have a connection to the remote SSH</span>
00926         <span class="comment">// Server which we may use to send commands/receive output</span>
00927         $p = array('process' =&gt; $process
00928                     ,'std_in' =&gt; $pipes[0]
00929                     ,'std_out' =&gt; $pipes[1]
00930                     ,'std_err' =&gt; $pipes[2] 
00931                     ,'stdout_file' =&gt; $child_stdout
00932                     ,'stderr_file' =&gt; $child_stderr
00933                    );
00934         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>)  {
00935             echo <span class="stringliteral">"process descriptor array is \n"</span>;
00936             print_r($p);
00937         }
00938         <span class="keywordflow">return</span> $p;
00939     }
00940     <span class="comment"></span>
00941 <span class="comment">    /**</span>
00942 <span class="comment">     *  Open an SSH connection to run an interactive command on a remote</span>
00943 <span class="comment">     * site</span>
00944 <span class="comment">     *</span>
00945 <span class="comment">     *  Connects to a remote host and runs an interactive command</span>
00946 <span class="comment">     * with NO controlling terminal.</span>
00947 <span class="comment">     *</span>
00948 <span class="comment">     *  This routine creates communication streams with the remote shell,</span>
00949 <span class="comment">     * and stores all output (standard and error) of the connection into</span>
00950 <span class="comment">     * two separate local log files (one for stdout and one for stderr).</span>
00951 <span class="comment">     *</span>
00952 <span class="comment">     *  Returns a process_control array which contains the process resource</span>
00953 <span class="comment">     * ID and an the standard file descriptors which the caller may use to</span>
00954 <span class="comment">     * interact with the remote shell.</span>
00955 <span class="comment">     *</span>
00956 <span class="comment">     * The process control array contains:</span>
00957 <span class="comment">     *</span>
00958 <span class="comment">     *  'process' -- the process resource for the newly created connection</span>
00959 <span class="comment">     *</span>
00960 <span class="comment">     *  'std_in' -- handle to the standard input of the new connection</span>
00961 <span class="comment">     *</span>
00962 <span class="comment">     *  'std_out' -- handle to standard output of the new connection</span>
00963 <span class="comment">     *</span>
00964 <span class="comment">     *  'std_err' -- handle to standard error of the new connection</span>
00965 <span class="comment">     *</span>
00966 <span class="comment">     *  'stdout_file' -- actual filename of the local log file for the</span>
00967 <span class="comment">     *          new connection standard output</span>
00968 <span class="comment">     *</span>
00969 <span class="comment">     *  'stderr_file' -- actual filename of the local log file for the</span>
00970 <span class="comment">     *          new connection standard error</span>
00971 <span class="comment">     *</span>
00972 <span class="comment">     *  @param  string command to be executed interactively on the remote end</span>
00973 <span class="comment">     *</span>
00974 <span class="comment">     *  @return mixed a process control associative array.</span>
00975 <span class="comment">     *</span>
00976 <span class="comment">     *  @access public</span>
00977 <span class="comment">     *  @since Method available since Release 1.0</span>
00978 <span class="comment">     */</span>
00979     function ssh_open_command($command)
00980     {   
00981         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
00982 
00983         <span class="comment">// Open a child process with the 'proc_open' function. </span>
00984         <span class="comment">//</span>
00985         <span class="comment">// Some tricks: we must open the connection using '-x' to disable</span>
00986         <span class="comment">// X11 forwarding, and use '-t -t' to avoid SSH generating an error</span>
00987         <span class="comment">// because we are not connected to any terminal.</span>
00988         <span class="comment">//</span>
00989         <span class="comment">// NOTE: if the web server is trusted remotely (i.e. it's SSH public </span>
00990         <span class="comment">// key is accepted in ~user@host:.ssh/authorized_keys) then any </span>
00991         <span class="comment">// password will do.</span>
00992 
00993         <span class="comment">// Prepare I/O</span>
00994         umask(0077);
00995         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) {
00996             <a class="code" href="test-pers_8php.html#a6">$child_stdout</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_cmd-"</span>.getmypid().<span class="stringliteral">"-1-"</span>);
00997             <a class="code" href="test-pers_8php.html#a7">$child_stderr</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_cmd-"</span>.getmypid().<span class="stringliteral">"-2-"</span>);
00998         } <span class="keywordflow">else</span> {
00999             <a class="code" href="test-pers_8php.html#a6">$child_stdout</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_cmd-"</span>);
01000             <a class="code" href="test-pers_8php.html#a7">$child_stderr</a> = tempnam($this-&gt;workdir, <span class="stringliteral">"open_cmd-"</span>);
01001         }
01002         <a class="code" href="test-pers_8php.html#a8">$descriptorspec</a> = array(
01003             0 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"r"</span>),  <span class="comment">// connect child's stdin to the read end of a pipe</span>
01004             #1 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"a"</span>),  <span class="comment">// connect child's stdout to the write end of a pipe</span>
01005             #2 =&gt; array(<span class="stringliteral">"pipe"</span>, <span class="stringliteral">"a"</span>)   <span class="comment">// stderr is a pipe to read from</span>
01006             1 =&gt; array(<span class="stringliteral">"file"</span>, $child_stdout, <span class="stringliteral">"a"</span>),
01007             2 =&gt; array(<span class="stringliteral">"file"</span>, $child_stderr, <span class="stringliteral">"a"</span>)
01008         );
01009 
01010         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote $command&lt;br /&gt;\n"</span>;
01011         <a class="code" href="test-pers_8php.html#a9">$process</a> = proc_open(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>, 
01012                          $descriptorspec,
01013                          $pipes);
01014         
01015         <span class="comment">// check status</span>
01016         <span class="keywordflow">if</span> (!is_resource($process)) 
01017         {
01018             <a class="code" href="util_8php.html#a4">letal</a>(<span class="stringliteral">"SSH::connect"</span>, <span class="stringliteral">"cannot connect to the remote host"</span>);
01019             <span class="keywordflow">return</span>;
01020         }
01021         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"proc_open done&lt;br /&gt;\n"</span>;
01022 
01023         <span class="comment">// $pipes now looks like this:</span>
01024         <span class="comment">//   0 =&gt; writeable handle connected to child stdin</span>
01025         
01026         <span class="comment">// Open child's stdin and stdout</span>
01027         $pipes[1] = fopen($child_stdout, <span class="stringliteral">"r"</span>);
01028         $pipes[2] = fopen($child_stderr, <span class="stringliteral">"r"</span>);
01029         
01030         <span class="comment">// Should we leave this to the user?</span>
01031         <span class="comment">// set to non-blocking and avoid having to call fflush</span>
01032 <span class="preprocessor">        #stream_set_blocking($pipes[0], FALSE);</span>
01033 <span class="preprocessor"></span><span class="preprocessor">        #stream_set_blocking($pipes[1], FALSE);</span>
01034 <span class="preprocessor"></span><span class="preprocessor">        #stream_set_blocking($pipes[2], FALSE);</span>
01035 <span class="preprocessor"></span>        stream_set_write_buffer($pipes[0], 0);
01036         stream_set_write_buffer($pipes[1], 0);
01037         stream_set_write_buffer($pipes[2], 0);
01038 
01039         <span class="comment">// We now have a connection to the remote SSH</span>
01040         <span class="comment">// Server which we may use to send commands/receive output</span>
01041         $p = array('process' =&gt; $process
01042                     ,'std_in' =&gt; $pipes[0]
01043                     ,'std_out' =&gt; $pipes[1]
01044                     ,'std_err' =&gt; $pipes[2] 
01045                     ,'stdout_file' =&gt; $child_stdout
01046                     ,'stderr_file' =&gt; $child_stderr
01047                    );
01048         <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>)  {
01049             echo <span class="stringliteral">"process descriptor array is \n"</span>;
01050             print_r($p);
01051         }
01052         <span class="keywordflow">return</span> $p;
01053     }
01054     <span class="comment"></span>
01055 <span class="comment">    /**</span>
01056 <span class="comment">     * Get output until we reach a given regular expression</span>
01057 <span class="comment">     *</span>
01058 <span class="comment">     *  @note EXPERIMENTAL, requires more thought and experience.</span>
01059 <span class="comment">     */</span>
01060     function ssh_out_expect($p, $expr=<span class="stringliteral">"^# "</span>)
01061     {
01062         <span class="keywordflow">do</span> {
01063                 flush();
01064                 fseek($p[<span class="stringliteral">"std_out"</span>], $last);
01065                 $line = fgets($p[<span class="stringliteral">"std_out"</span>], 1024);
01066 <span class="preprocessor">                 #echo "&gt;&gt; ".$line;</span>
01067 <span class="preprocessor"></span>                <a class="code" href="ssh__test_8php.html#a2">$last</a> = ftell($p[<span class="stringliteral">"std_out"</span>]);
01068         } <span class="keywordflow">while</span> ((! feof($p[<span class="stringliteral">"std_out"</span>]) ) || (! ereg($expr, $line)));
01069     }
01070 <span class="comment"></span>
01071 <span class="comment">    /**</span>
01072 <span class="comment">     * Close an SSH interactive session</span>
01073 <span class="comment">     *</span>
01074 <span class="comment">     *  This method terminates a previously open interactive remote </span>
01075 <span class="comment">     * session. It will send a termination notification to the</span>
01076 <span class="comment">     * remote end, close the connection with control and communication</span>
01077 <span class="comment">     * streams, and terminate the local control process.</span>
01078 <span class="comment">     *</span>
01079 <span class="comment">     *  Copies of the log files that contain the output and error</span>
01080 <span class="comment">     * of the communication are left out for later reference and </span>
01081 <span class="comment">     * local peruse. If you don't need them any longer, you may</span>
01082 <span class="comment">     * delete them or just leave them around until the class destructor</span>
01083 <span class="comment">     * is called (which will remove all session traces),</span>
01084 <span class="comment">     *</span>
01085 <span class="comment">     *  @param mixed p an associative array with the description of the interactive</span>
01086 <span class="comment">     *          session control process, obtained by a previous call to one</span>
01087 <span class="comment">     *          of the interactive session creation methods ssh_open_shell()</span>
01088 <span class="comment">     *          or ssh_open_command().</span>
01089 <span class="comment">     *</span>
01090 <span class="comment">     *  @return integer the exit status of the remote interactive session.</span>
01091 <span class="comment">     *</span>
01092 <span class="comment">     *  @access public</span>
01093 <span class="comment">     *  @since Method available since Release 1.0</span>
01094 <span class="comment">     */</span>
01095     function ssh_close($p)
01096     {
01097         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
01098         
01099             fwrite($p['std_in'], <span class="stringliteral">"\n"</span>);
01100             fwrite($p['std_in'], <span class="stringliteral">"logout\n"</span>);
01101             fflush($p['std_in']);
01102             fclose($p['std_in']); fclose($p['std_out']); fclose($p['std_err']);
01103             <span class="keywordflow">if</span> (<a class="code" href="ssh__test_8php.html#a0">$debug</a>) echo <span class="stringliteral">"pipes/files closed\n"</span>;
01104             <span class="comment">// XXX we should delete the log files here...</span>
01105             <span class="keywordflow">return</span> proc_close($p['process']);
01106     }
01107     
01108 <span class="preprocessor">#    if ($php_version &gt;= 5)</span>
01109 <span class="preprocessor"></span><span class="preprocessor">#    {</span>
01110 <span class="preprocessor"></span><span class="preprocessor">#       </span><span class="comment">/**</span>
01111 <span class="comment">#        * send a signal to a running ssh_open_* process</span>
01112 <span class="comment">#        */</span>
01113 <span class="preprocessor">#       function ssh_signal($p, $signal)</span>
01114 <span class="preprocessor"></span><span class="preprocessor">#       {</span>
01115 <span class="preprocessor"></span><span class="preprocessor">#           return proc_terminate($p['process'], $signal);</span>
01116 <span class="preprocessor"></span><span class="preprocessor">#       }</span>
01117 <span class="preprocessor"></span><span class="preprocessor">#       </span><span class="comment">/**</span>
01118 <span class="comment">#        * get info about a running ssh_open_* process</span>
01119 <span class="comment">#        */</span>
01120 <span class="preprocessor">#       function ssh_get_status($p)</span>
01121 <span class="preprocessor"></span><span class="preprocessor">#       {</span>
01122 <span class="preprocessor"></span><span class="preprocessor">#           return proc_get_status($p['process']);</span>
01123 <span class="preprocessor"></span><span class="preprocessor">#       }</span>
01124 <span class="preprocessor"></span><span class="preprocessor">#    }</span>
01125 <span class="preprocessor"></span>    <span class="comment"></span>
01126 <span class="comment">    /**</span>
01127 <span class="comment">     *  Execute a remote command and keep an unidirectional stream</span>
01128 <span class="comment">     * contact with it.</span>
01129 <span class="comment">     *</span>
01130 <span class="comment">     *  This routine mimics 'popen()' but uses ssh to connect to</span>
01131 <span class="comment">     * a remote host and run the requested command: in other words,</span>
01132 <span class="comment">     * it opens a pipe to a remotely executed command. This pipe is</span>
01133 <span class="comment">     * unidirectional, with the communications direction controlled</span>
01134 <span class="comment">     * by a method parameter.</span>
01135 <span class="comment">     *</span>
01136 <span class="comment">     *  @see popen() for more details.</span>
01137 <span class="comment">     *</span>
01138 <span class="comment">     *  @param string command is the command to execute on the remote end</span>
01139 <span class="comment">     *</span>
01140 <span class="comment">     *  @param string mode specifies the communications direction for the </span>
01141 <span class="comment">     *          pipe: if set to "r" (read), then we will be able to</span>
01142 <span class="comment">     *          collect command output only; if set to "w" (write)</span>
01143 <span class="comment">     *          then we may only send input to the remote command.</span>
01144 <span class="comment">     *</span>
01145 <span class="comment">     *  @return resource a handle to the unidirectional communication stream,</span>
01146 <span class="comment">     *          similar to that returned by fopen(), or FALSE on</span>
01147 <span class="comment">     *          failure. This handle must be closed with ssh_pclose().</span>
01148 <span class="comment">     *</span>
01149 <span class="comment">     *  @access public</span>
01150 <span class="comment">     *  @since Method available since Release 1.0</span>
01151 <span class="comment">     */</span>
01152     function ssh_popen($command, $mode)
01153     {
01154         global <a class="code" href="ssh__test_8php.html#a0">$debug</a>;
01155 
01156         <span class="comment">// go</span>
01157         <span class="keywordflow">return</span> popen(<span class="stringliteral">"$this-&gt;ssh -x -t -t -S $this-&gt;mplex_socket $this-&gt;remote \"$command\""</span>, $mode);
01158     }
01159     <span class="comment"></span>
01160 <span class="comment">    /**</span>
01161 <span class="comment">     * Close a piped remote execution command control pipe.</span>
01162 <span class="comment">     *</span>
01163 <span class="comment">     *  This routine accepts as input the handle for the control stream</span>
01164 <span class="comment">     * of a remote command and closes it, terminating the command as well.</span>
01165 <span class="comment">     * The handle must be valid and obtained through a call to ssh_popen().</span>
01166 <span class="comment">     *</span>
01167 <span class="comment">     *  @param resource f is the file handle associated with the pipe control stream</span>
01168 <span class="comment">     *</span>
01169 <span class="comment">     *  @return integer the termination status of the command that was run.</span>
01170 <span class="comment">     *</span>
01171 <span class="comment">     *  @access public</span>
01172 <span class="comment">     *  @since Method available since Release 1.0</span>
01173 <span class="comment">     */</span>
01174     function ssh_pclose($f)
01175     {
01176         <span class="keywordflow">return</span> pclose($f);
01177     }
01178 
01179     <span class="comment">//}}}</span>
01180 }
01181 
01182 <span class="comment">/*</span>
01183 <span class="comment"> * Local variables:</span>
01184 <span class="comment"> * tab-width: 4</span>
01185 <span class="comment"> * c-basic-offset: 4</span>
01186 <span class="comment"> * c-hanging-comment-ender-p: nil</span>
01187 <span class="comment"> * End:</span>
01188 <span class="comment"> */</span>
01189 
01190 ?&gt;
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed May 25 19:14:05 2005 for php::ssh by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > </a>1.3.6 </small></address>
</body>
</html>
